{"ast":null,"code":"/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\n\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\n\nfunction getAxisMap(element, _ref, _ref2) {\n  let {\n    x,\n    y\n  } = _ref;\n  let {\n    xAxisID,\n    yAxisID\n  } = _ref2;\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {\n      axisId: xAxisID\n    };\n  });\n  each(y, key => {\n    axisMap[key] = {\n      axisId: yAxisID\n    };\n  });\n  return axisMap;\n}\n\nconst cancelAnimFrame = function () {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n\n  return window.cancelAnimationFrame;\n}();\n\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\n\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\n\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\n\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? {\n    value: scale.getPixelForValue(value),\n    transitionable: true\n  } : {\n    value: fallback\n  };\n}\n\nfunction updateBoxAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {\n        axisId: xScaleID\n      };\n    }\n\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {\n        axisId: xScaleID\n      };\n    }\n\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {\n        axisId: xScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {\n        axisId: yScaleID\n      };\n    }\n\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {\n        axisId: yScaleID\n      };\n    }\n\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {\n        axisId: yScaleID,\n        reverse: min.transitionable\n      };\n    }\n  }\n}\n\nfunction updateLineAnnotation(element, chart, options) {\n  const {\n    scales,\n    chartArea\n  } = chart;\n  const {\n    scaleID,\n    value\n  } = options;\n  const scale = scales[scaleID];\n  const {\n    top,\n    left,\n    bottom,\n    right\n  } = chartArea;\n  const streaming = element.$streaming = {};\n\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {\n        axisId: scaleID\n      };\n      streaming[isHorizontal ? 'x2' : 'y2'] = {\n        axisId: scaleID\n      };\n    }\n\n    return isHorizontal ? {\n      top,\n      bottom\n    } : {\n      left,\n      right\n    };\n  }\n\n  const {\n    xScaleID,\n    yScaleID,\n    xMin,\n    xMax,\n    yMin,\n    yMax\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n\n    if (min.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.left = left;\n    }\n\n    if (max.transitionable) {\n      streaming.x2 = {\n        axisId: xScaleID\n      };\n    } else {\n      clip.right = right;\n    }\n  }\n\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n\n    if (min.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.top = top;\n    }\n\n    if (max.transitionable) {\n      streaming.y2 = {\n        axisId: yScaleID\n      };\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n\n  return clip;\n}\n\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {\n    xScaleID,\n    yScaleID,\n    xValue,\n    yValue\n  } = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n\n    if (x.transitionable) {\n      streaming.x = {\n        axisId: xScaleID\n      };\n    }\n  }\n\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n\n    if (y.transitionable) {\n      streaming.y = {\n        axisId: yScaleID\n      };\n    }\n  }\n}\n\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n\n  BoxAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n\n  LineAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n\n  PointAnnotation.prototype.resolveElementProperties = function (chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\n\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n\n      afterUpdate.call(this, _chart, args, options);\n\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\n\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n\n  if (plugin) {\n    const state = plugin._getState(chart);\n\n    return state && state.elements || [];\n  }\n\n  return [];\n}\n\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {\n  x: ['x', 'caretX'],\n  y: ['y', 'caretY']\n};\n\nfunction update$1() {\n  const me = this;\n  const element = me.getActiveElements()[0];\n\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\n\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n\n  if (!state) {\n    state = {\n      originalScaleOptions: {}\n    };\n    chartStates.set(chart, state);\n  }\n\n  return state;\n}\n\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\n\nfunction storeOriginalScaleOptions(chart) {\n  const {\n    originalScaleOptions\n  } = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\n\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDuration = 0,\n    maxDuration = Infinity,\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\n\nfunction panRealTimeScale(scale, delta, limits) {\n  const {\n    chart,\n    axis\n  } = scale;\n  const {\n    minDelay = -Infinity,\n    maxDelay = Infinity\n  } = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\n\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\n\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\n\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n\n    streaming.zoomPlugin = plugin;\n  }\n}\n\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\n\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {\n    size: milliseconds,\n    steps\n  } = INTERVALS[unit];\n  let factor;\n\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n\n  return factor;\n}\n\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {\n      common,\n      size,\n      steps\n    } = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n\n  return UNITS[ilen - 1];\n}\n\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\n\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {\n      lo,\n      hi\n    } = _lookup(timestamps, time);\n\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\n\nconst datasetPropertyKeys = ['pointBackgroundColor', 'pointBorderColor', 'pointBorderWidth', 'pointRadius', 'pointRotation', 'pointStyle', 'pointHitRadius', 'pointHoverBackgroundColor', 'pointHoverBorderColor', 'pointHoverBorderWidth', 'pointHoverRadius', 'backgroundColor', 'borderColor', 'borderSkipped', 'borderWidth', 'hoverBackgroundColor', 'hoverBorderColor', 'hoverBorderWidth', 'hoverRadius', 'hitRadius', 'radius', 'rotation'];\n\nfunction clean(scale) {\n  const {\n    chart,\n    id,\n    max\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n\n      count = i - start;\n\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\n\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\n\nfunction scroll(scale) {\n  const {\n    chart,\n    id,\n    $realtime: realtime\n  } = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {\n      data: elements = [],\n      dataset: element\n    } = meta;\n\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\n\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {\n      $realtime: realtime,\n      options\n    } = me;\n    const {\n      bounds,\n      offset,\n      ticks: ticksOpts\n    } = options;\n    const {\n      autoSkip,\n      source,\n      major: majorTicksOpts\n    } = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n\n        return resolveOption(me, 'frameRate');\n      });\n    }\n\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n\n      me._handleMargins();\n    }\n  }\n\n  draw(chartArea) {\n    const me = this;\n    const {\n      chart,\n      ctx\n    } = me;\n    const area = me.isHorizontal() ? {\n      left: chartArea.left,\n      top: 0,\n      right: chartArea.right,\n      bottom: chart.height\n    } : {\n      left: 0,\n      top: chartArea.top,\n      right: chart.width,\n      bottom: chartArea.bottom\n    };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n\n    const capacity = me._getLabelCapacity(min);\n\n    const {\n      time: timeOpts,\n      ticks: ticksOpts\n    } = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n\n    time = first;\n\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n\n}\n\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\nvar version = \"2.0.0\";\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {\n  x: ['x', 'cp1x', 'cp2x'],\n  y: ['y', 'cp1y', 'cp2y']\n};\n\nfunction update(mode) {\n  const me = this;\n\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n\n      controller._setStyle = function (element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n\n  Chart.prototype.update.call(me, mode);\n\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\n\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\n\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {\n      render\n    };\n    const canvas = streaming.canvas = chart.canvas;\n\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n\n  afterInit(chart) {\n    chart.update = update;\n  },\n\n  beforeUpdate(chart) {\n    const {\n      scales,\n      elements\n    } = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, _ref3 => {\n      let {\n        type\n      } = _ref3;\n\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n\n  beforeDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n\n    if (mode === 'quiet') {\n      const {\n        controller,\n        $animations\n      } = meta;\n\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n\n  afterDatasetUpdate(chart, args) {\n    const {\n      meta,\n      mode\n    } = args;\n    const {\n      data: elements = [],\n      dataset: element,\n      controller\n    } = meta;\n\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n\n  beforeDatasetDraw(chart, args) {\n    const {\n      ctx,\n      chartArea,\n      width,\n      height\n    } = chart;\n    const {\n      xAxisID,\n      yAxisID,\n      controller\n    } = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n\n    clipArea(ctx, area);\n  },\n\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n\n  destroy(chart) {\n    const {\n      scales,\n      $streaming: streaming,\n      tooltip\n    } = chart;\n    const {\n      canvas,\n      mouseEventListener\n    } = streaming;\n    delete chart.update;\n\n    if (tooltip) {\n      delete tooltip.update;\n    }\n\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\nconst registerables = [StreamingPlugin, RealTimeScale];\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };","map":{"version":3,"names":["registry","TimeScale","defaults","DatasetController","Chart","valueOrDefault","each","requestAnimFrame","callback","noop","isFinite","clipArea","unclipArea","isNumber","_lookup","isArray","getRelativePosition","clamp","value","lower","upper","Math","min","max","resolveOption","scale","key","realtimeOpts","options","realtime","streamingOpts","chart","plugins","streaming","getAxisMap","element","x","y","xAxisID","yAxisID","axisMap","axisId","cancelAnimFrame","window","cancelAnimationFrame","startFrameRefreshTimer","context","func","frameRequestID","refresh","nextRefresh","now","Date","newFrameRate","frameDuration","newNextRefresh","call","stopFrameRefreshTimer","stopDataRefreshTimer","refreshTimerID","clearInterval","refreshInterval","startDataRefreshTimer","interval","setInterval","newInterval","isNaN","scaleValue","fallback","parse","getPixelForValue","transitionable","updateBoxAnnotation","scales","chartArea","xScaleID","yScaleID","xMin","xMax","yMin","yMax","xScale","yScale","top","left","bottom","right","$streaming","reverse","width","height","updateLineAnnotation","scaleID","isHorizontal","pixel","clip","x2","y2","updatePointAnnotation","xValue","yValue","initAnnotationPlugin","BoxAnnotation","getElement","LineAnnotation","PointAnnotation","resolveBoxAnnotationProperties","prototype","resolveElementProperties","resolveLineAnnotationProperties","resolvePointAnnotationProperties","properties","attachChart$1","plugin","annotationPlugin","afterUpdate","_chart","args","mode","animationOpts","animation","getElements","state","_getState","elements","detachChart$1","transitionKeys$1","update$1","me","getActiveElements","meta","getDatasetMeta","datasetIndex","constructor","update","chartStates","WeakMap","getState","get","originalScaleOptions","set","removeState","delete","storeOriginalScaleOptions","id","duration","delay","opt","zoomRealTimeScale","zoom","center","limits","axis","minDuration","maxDuration","Infinity","minDelay","maxDelay","newDuration","maxPercent","newDelay","panRealTimeScale","delta","getValueForPixel","resetRealTimeScaleOptions","realtimeOptions","original","initZoomPlugin","zoomFunctions","panFunctions","attachChart","zoomPlugin","resetZoom","transition","detachChart","INTERVALS","millisecond","common","size","steps","second","minute","hour","day","week","month","quarter","year","UNITS","Object","keys","determineStepSize","unit","capacity","range","milliseconds","factor","ceil","i","ilen","length","determineUnitForAutoTicks","minUnit","indexOf","Number","MAX_SAFE_INTEGER","determineMajorUnit","addTick","ticks","time","timestamps","lo","hi","timestamp","datasetPropertyKeys","clean","ttl","pause","start","count","removalRange","data","datasets","dataset","controller","point","getParsed","splice","datalabels","_active","item","index","labels","translate","animations","$animations","_from","_to","scroll","$realtime","tooltip","annotations","offset","head","_path","RealTimeScale","props","init","scaleOpts","opts","onRefresh","maxWidth","maxHeight","margins","bounds","ticksOpts","autoSkip","source","major","majorTicksOpts","majorEnabled","enabled","render","undefined","buildTicks","maxArray","minArray","defineProperty","shift","calculateLabelRotation","maxRotation","minRotation","fit","display","paddingLeft","paddingRight","_handleMargins","draw","ctx","area","_gridLineItems","_labelItems","destroy","_generate","adapter","_adapter","_getLabelCapacity","timeOpts","minor","stepSize","weekday","isoWeekday","majorTicksEnabled","hasWeekday","first","startOf","diff","Error","round","add","getDataTimestamps","sort","a","b","map","adapters","parser","displayFormats","describe","_scriptable","name","version","quiet","transitionKeys","_setStyle","_mode","active","lastMouseEvent","setTimeout","_eventHandler","StreamingPlugin","beforeInit","canvas","mouseEventListener","event","pos","type","native","addEventListener","afterInit","beforeUpdate","line","capBezierPoints","getPlugin","e","beforeDatasetUpdate","visible","updateElement","updateSharedOptions","afterDatasetUpdate","beforeDatasetDraw","getScaleForId","afterDatasetDraw","beforeEvent","removeEventListener","frameRate","descriptors","registerables"],"sources":["C:/Users/user/Documents/cameraProject_frontend-main/node_modules/chartjs-plugin-streaming/dist/chartjs-plugin-streaming.esm.js"],"sourcesContent":["/*!\n * chartjs-plugin-streaming v2.0.0\n * https://nagix.github.io/chartjs-plugin-streaming\n * (c) 2017-2021 Akihiko Kusanagi\n * Released under the MIT license\n */\nimport { registry, TimeScale, defaults, DatasetController, Chart } from 'chart.js';\nimport { valueOrDefault, each, requestAnimFrame, callback, noop, isFinite, clipArea, unclipArea, isNumber, _lookup, isArray, getRelativePosition } from 'chart.js/helpers';\n\nfunction clamp(value, lower, upper) {\n  return Math.min(Math.max(value, lower), upper);\n}\nfunction resolveOption(scale, key) {\n  const realtimeOpts = scale.options.realtime;\n  const streamingOpts = scale.chart.options.plugins.streaming;\n  return valueOrDefault(realtimeOpts[key], streamingOpts[key]);\n}\nfunction getAxisMap(element, {x, y}, {xAxisID, yAxisID}) {\n  const axisMap = {};\n  each(x, key => {\n    axisMap[key] = {axisId: xAxisID};\n  });\n  each(y, key => {\n    axisMap[key] = {axisId: yAxisID};\n  });\n  return axisMap;\n}\nconst cancelAnimFrame = (function() {\n  if (typeof window === 'undefined') {\n    return noop;\n  }\n  return window.cancelAnimationFrame;\n}());\nfunction startFrameRefreshTimer(context, func) {\n  if (!context.frameRequestID) {\n    const refresh = () => {\n      const nextRefresh = context.nextRefresh || 0;\n      const now = Date.now();\n      if (nextRefresh <= now) {\n        const newFrameRate = callback(func);\n        const frameDuration = 1000 / (Math.max(newFrameRate, 0) || 30);\n        const newNextRefresh = context.nextRefresh + frameDuration || 0;\n        context.nextRefresh = newNextRefresh > now ? newNextRefresh : now + frameDuration;\n      }\n      context.frameRequestID = requestAnimFrame.call(window, refresh);\n    };\n    context.frameRequestID = requestAnimFrame.call(window, refresh);\n  }\n}\nfunction stopFrameRefreshTimer(context) {\n  const frameRequestID = context.frameRequestID;\n  if (frameRequestID) {\n    cancelAnimFrame.call(window, frameRequestID);\n    delete context.frameRequestID;\n  }\n}\nfunction stopDataRefreshTimer(context) {\n  const refreshTimerID = context.refreshTimerID;\n  if (refreshTimerID) {\n    clearInterval(refreshTimerID);\n    delete context.refreshTimerID;\n    delete context.refreshInterval;\n  }\n}\nfunction startDataRefreshTimer(context, func, interval) {\n  if (!context.refreshTimerID) {\n    context.refreshTimerID = setInterval(() => {\n      const newInterval = callback(func);\n      if (context.refreshInterval !== newInterval && !isNaN(newInterval)) {\n        stopDataRefreshTimer(context);\n        startDataRefreshTimer(context, func, newInterval);\n      }\n    }, interval || 0);\n    context.refreshInterval = interval || 0;\n  }\n}\n\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ?\n    {value: scale.getPixelForValue(value), transitionable: true} :\n    {value: fallback};\n}\nfunction updateBoxAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin, left);\n    const max = scaleValue(xScale, xMax, right);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'x2' : 'x'] = {axisId: xScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'x' : 'x2'] = {axisId: xScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.width = {axisId: xScaleID, reverse: min.transitionable};\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin, top);\n    const max = scaleValue(yScale, yMax, bottom);\n    const reverse = min.value > max.value;\n    if (min.transitionable) {\n      streaming[reverse ? 'y2' : 'y'] = {axisId: yScaleID};\n    }\n    if (max.transitionable) {\n      streaming[reverse ? 'y' : 'y2'] = {axisId: yScaleID};\n    }\n    if (min.transitionable !== max.transitionable) {\n      streaming.height = {axisId: yScaleID, reverse: min.transitionable};\n    }\n  }\n}\nfunction updateLineAnnotation(element, chart, options) {\n  const {scales, chartArea} = chart;\n  const {scaleID, value} = options;\n  const scale = scales[scaleID];\n  const {top, left, bottom, right} = chartArea;\n  const streaming = element.$streaming = {};\n  if (scale) {\n    const isHorizontal = scale.isHorizontal();\n    const pixel = scaleValue(scale, value);\n    if (pixel.transitionable) {\n      streaming[isHorizontal ? 'x' : 'y'] = {axisId: scaleID};\n      streaming[isHorizontal ? 'x2' : 'y2'] = {axisId: scaleID};\n    }\n    return isHorizontal ? {top, bottom} : {left, right};\n  }\n  const {xScaleID, yScaleID, xMin, xMax, yMin, yMax} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const clip = {};\n  if (xScale) {\n    const min = scaleValue(xScale, xMin);\n    const max = scaleValue(xScale, xMax);\n    if (min.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    } else {\n      clip.left = left;\n    }\n    if (max.transitionable) {\n      streaming.x2 = {axisId: xScaleID};\n    } else {\n      clip.right = right;\n    }\n  }\n  if (yScale) {\n    const min = scaleValue(yScale, yMin);\n    const max = scaleValue(yScale, yMax);\n    if (min.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    } else {\n      clip.top = top;\n    }\n    if (max.transitionable) {\n      streaming.y2 = {axisId: yScaleID};\n    } else {\n      clip.bottom = bottom;\n    }\n  }\n  return clip;\n}\nfunction updatePointAnnotation(element, chart, options) {\n  const scales = chart.scales;\n  const {xScaleID, yScaleID, xValue, yValue} = options;\n  const xScale = scales[xScaleID];\n  const yScale = scales[yScaleID];\n  const streaming = element.$streaming = {};\n  if (xScale) {\n    const x = scaleValue(xScale, xValue);\n    if (x.transitionable) {\n      streaming.x = {axisId: xScaleID};\n    }\n  }\n  if (yScale) {\n    const y = scaleValue(yScale, yValue);\n    if (y.transitionable) {\n      streaming.y = {axisId: yScaleID};\n    }\n  }\n}\nfunction initAnnotationPlugin() {\n  const BoxAnnotation = registry.getElement('boxAnnotation');\n  const LineAnnotation = registry.getElement('lineAnnotation');\n  const PointAnnotation = registry.getElement('pointAnnotation');\n  const resolveBoxAnnotationProperties = BoxAnnotation.prototype.resolveElementProperties;\n  const resolveLineAnnotationProperties = LineAnnotation.prototype.resolveElementProperties;\n  const resolvePointAnnotationProperties = PointAnnotation.prototype.resolveElementProperties;\n  BoxAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updateBoxAnnotation(this, chart, options);\n    return resolveBoxAnnotationProperties.call(this, chart, options);\n  };\n  LineAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    const chartArea = chart.chartArea;\n    chart.chartArea = updateLineAnnotation(this, chart, options);\n    const properties = resolveLineAnnotationProperties.call(this, chart, options);\n    chart.chartArea = chartArea;\n    return properties;\n  };\n  PointAnnotation.prototype.resolveElementProperties = function(chart, options) {\n    updatePointAnnotation(this, chart, options);\n    return resolvePointAnnotationProperties.call(this, chart, options);\n  };\n}\nfunction attachChart$1(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.annotationPlugin !== plugin) {\n    const afterUpdate = plugin.afterUpdate;\n    initAnnotationPlugin();\n    streaming.annotationPlugin = plugin;\n    plugin.afterUpdate = (_chart, args, options) => {\n      const mode = args.mode;\n      const animationOpts = options.animation;\n      if (mode === 'quiet') {\n        options.animation = false;\n      }\n      afterUpdate.call(this, _chart, args, options);\n      if (mode === 'quiet') {\n        options.animation = animationOpts;\n      }\n    };\n  }\n}\nfunction getElements(chart) {\n  const plugin = chart.$streaming.annotationPlugin;\n  if (plugin) {\n    const state = plugin._getState(chart);\n    return state && state.elements || [];\n  }\n  return [];\n}\nfunction detachChart$1(chart) {\n  delete chart.$streaming.annotationPlugin;\n}\n\nconst transitionKeys$1 = {x: ['x', 'caretX'], y: ['y', 'caretY']};\nfunction update$1(...args) {\n  const me = this;\n  const element = me.getActiveElements()[0];\n  if (element) {\n    const meta = me._chart.getDatasetMeta(element.datasetIndex);\n    me.$streaming = getAxisMap(me, transitionKeys$1, meta);\n  } else {\n    me.$streaming = {};\n  }\n  me.constructor.prototype.update.call(me, ...args);\n}\n\nconst chartStates = new WeakMap();\nfunction getState(chart) {\n  let state = chartStates.get(chart);\n  if (!state) {\n    state = {originalScaleOptions: {}};\n    chartStates.set(chart, state);\n  }\n  return state;\n}\nfunction removeState(chart) {\n  chartStates.delete(chart);\n}\nfunction storeOriginalScaleOptions(chart) {\n  const {originalScaleOptions} = getState(chart);\n  const scales = chart.scales;\n  each(scales, scale => {\n    const id = scale.id;\n    if (!originalScaleOptions[id]) {\n      originalScaleOptions[id] = {\n        duration: resolveOption(scale, 'duration'),\n        delay: resolveOption(scale, 'delay')\n      };\n    }\n  });\n  each(originalScaleOptions, (opt, key) => {\n    if (!scales[key]) {\n      delete originalScaleOptions[key];\n    }\n  });\n  return originalScaleOptions;\n}\nfunction zoomRealTimeScale(scale, zoom, center, limits) {\n  const {chart, axis} = scale;\n  const {minDuration = 0, maxDuration = Infinity, minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const realtimeOpts = scale.options.realtime;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const newDuration = clamp(duration * (2 - zoom), minDuration, maxDuration);\n  let maxPercent, newDelay;\n  storeOriginalScaleOptions(chart);\n  if (scale.isHorizontal()) {\n    maxPercent = (scale.right - center.x) / (scale.right - scale.left);\n  } else {\n    maxPercent = (scale.bottom - center.y) / (scale.bottom - scale.top);\n  }\n  newDelay = delay + maxPercent * (duration - newDuration);\n  realtimeOpts.duration = newDuration;\n  realtimeOpts.delay = clamp(newDelay, minDelay, maxDelay);\n  return newDuration !== scale.max - scale.min;\n}\nfunction panRealTimeScale(scale, delta, limits) {\n  const {chart, axis} = scale;\n  const {minDelay = -Infinity, maxDelay = Infinity} = limits && limits[axis] || {};\n  const delay = resolveOption(scale, 'delay');\n  const newDelay = delay + (scale.getValueForPixel(delta) - scale.getValueForPixel(0));\n  storeOriginalScaleOptions(chart);\n  scale.options.realtime.delay = clamp(newDelay, minDelay, maxDelay);\n  return true;\n}\nfunction resetRealTimeScaleOptions(chart) {\n  const originalScaleOptions = storeOriginalScaleOptions(chart);\n  each(chart.scales, scale => {\n    const realtimeOptions = scale.options.realtime;\n    if (realtimeOptions) {\n      const original = originalScaleOptions[scale.id];\n      if (original) {\n        realtimeOptions.duration = original.duration;\n        realtimeOptions.delay = original.delay;\n      } else {\n        delete realtimeOptions.duration;\n        delete realtimeOptions.delay;\n      }\n    }\n  });\n}\nfunction initZoomPlugin(plugin) {\n  plugin.zoomFunctions.realtime = zoomRealTimeScale;\n  plugin.panFunctions.realtime = panRealTimeScale;\n}\nfunction attachChart(plugin, chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin !== plugin) {\n    const resetZoom = streaming.resetZoom = chart.resetZoom;\n    initZoomPlugin(plugin);\n    chart.resetZoom = transition => {\n      resetRealTimeScaleOptions(chart);\n      resetZoom(transition);\n    };\n    streaming.zoomPlugin = plugin;\n  }\n}\nfunction detachChart(chart) {\n  const streaming = chart.$streaming;\n  if (streaming.zoomPlugin) {\n    chart.resetZoom = streaming.resetZoom;\n    removeState(chart);\n    delete streaming.resetZoom;\n    delete streaming.zoomPlugin;\n  }\n}\n\nconst INTERVALS = {\n  millisecond: {\n    common: true,\n    size: 1,\n    steps: [1, 2, 5, 10, 20, 50, 100, 250, 500]\n  },\n  second: {\n    common: true,\n    size: 1000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  minute: {\n    common: true,\n    size: 60000,\n    steps: [1, 2, 5, 10, 15, 30]\n  },\n  hour: {\n    common: true,\n    size: 3600000,\n    steps: [1, 2, 3, 6, 12]\n  },\n  day: {\n    common: true,\n    size: 86400000,\n    steps: [1, 2, 5]\n  },\n  week: {\n    common: false,\n    size: 604800000,\n    steps: [1, 2, 3, 4]\n  },\n  month: {\n    common: true,\n    size: 2.628e9,\n    steps: [1, 2, 3]\n  },\n  quarter: {\n    common: false,\n    size: 7.884e9,\n    steps: [1, 2, 3, 4]\n  },\n  year: {\n    common: true,\n    size: 3.154e10\n  }\n};\nconst UNITS = Object.keys(INTERVALS);\nfunction determineStepSize(min, max, unit, capacity) {\n  const range = max - min;\n  const {size: milliseconds, steps} = INTERVALS[unit];\n  let factor;\n  if (!steps) {\n    return Math.ceil(range / (capacity * milliseconds));\n  }\n  for (let i = 0, ilen = steps.length; i < ilen; ++i) {\n    factor = steps[i];\n    if (Math.ceil(range / (milliseconds * factor)) <= capacity) {\n      break;\n    }\n  }\n  return factor;\n}\nfunction determineUnitForAutoTicks(minUnit, min, max, capacity) {\n  const range = max - min;\n  const ilen = UNITS.length;\n  for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {\n    const {common, size, steps} = INTERVALS[UNITS[i]];\n    const factor = steps ? steps[steps.length - 1] : Number.MAX_SAFE_INTEGER;\n    if (common && Math.ceil(range / (factor * size)) <= capacity) {\n      return UNITS[i];\n    }\n  }\n  return UNITS[ilen - 1];\n}\nfunction determineMajorUnit(unit) {\n  for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {\n    if (INTERVALS[UNITS[i]].common) {\n      return UNITS[i];\n    }\n  }\n}\nfunction addTick(ticks, time, timestamps) {\n  if (!timestamps) {\n    ticks[time] = true;\n  } else if (timestamps.length) {\n    const {lo, hi} = _lookup(timestamps, time);\n    const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];\n    ticks[timestamp] = true;\n  }\n}\nconst datasetPropertyKeys = [\n  'pointBackgroundColor',\n  'pointBorderColor',\n  'pointBorderWidth',\n  'pointRadius',\n  'pointRotation',\n  'pointStyle',\n  'pointHitRadius',\n  'pointHoverBackgroundColor',\n  'pointHoverBorderColor',\n  'pointHoverBorderWidth',\n  'pointHoverRadius',\n  'backgroundColor',\n  'borderColor',\n  'borderSkipped',\n  'borderWidth',\n  'hoverBackgroundColor',\n  'hoverBorderColor',\n  'hoverBorderWidth',\n  'hoverRadius',\n  'hitRadius',\n  'radius',\n  'rotation'\n];\nfunction clean(scale) {\n  const {chart, id, max} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const ttl = resolveOption(scale, 'ttl');\n  const pause = resolveOption(scale, 'pause');\n  const min = Date.now() - (isNaN(ttl) ? duration + delay : ttl);\n  let i, start, count, removalRange;\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const axis = id === meta.xAxisID && 'x' || id === meta.yAxisID && 'y';\n    if (axis) {\n      const controller = meta.controller;\n      const data = dataset.data;\n      const length = data.length;\n      if (pause) {\n        for (i = 0; i < length; ++i) {\n          const point = controller.getParsed(i);\n          if (point && !(point[axis] < max)) {\n            break;\n          }\n        }\n        start = i + 2;\n      } else {\n        start = 0;\n      }\n      for (i = start; i < length; ++i) {\n        const point = controller.getParsed(i);\n        if (!point || !(point[axis] <= min)) {\n          break;\n        }\n      }\n      count = i - start;\n      if (isNaN(ttl)) {\n        count = Math.max(count - 2, 0);\n      }\n      data.splice(start, count);\n      each(datasetPropertyKeys, key => {\n        if (isArray(dataset[key])) {\n          dataset[key].splice(start, count);\n        }\n      });\n      each(dataset.datalabels, value => {\n        if (isArray(value)) {\n          value.splice(start, count);\n        }\n      });\n      if (typeof data[0] !== 'object') {\n        removalRange = {\n          start: start,\n          count: count\n        };\n      }\n      each(chart._active, (item, index) => {\n        if (item.datasetIndex === datasetIndex && item.index >= start) {\n          if (item.index >= start + count) {\n            item.index -= count;\n          } else {\n            chart._active.splice(index, 1);\n          }\n        }\n      }, null, true);\n    }\n  });\n  if (removalRange) {\n    chart.data.labels.splice(removalRange.start, removalRange.count);\n  }\n}\nfunction transition(element, id, translate) {\n  const animations = element.$animations || {};\n  each(element.$streaming, (item, key) => {\n    if (item.axisId === id) {\n      const delta = item.reverse ? -translate : translate;\n      const animation = animations[key];\n      if (isFinite(element[key])) {\n        element[key] -= delta;\n      }\n      if (animation) {\n        animation._from -= delta;\n        animation._to -= delta;\n      }\n    }\n  });\n}\nfunction scroll(scale) {\n  const {chart, id, $realtime: realtime} = scale;\n  const duration = resolveOption(scale, 'duration');\n  const delay = resolveOption(scale, 'delay');\n  const isHorizontal = scale.isHorizontal();\n  const length = isHorizontal ? scale.width : scale.height;\n  const now = Date.now();\n  const tooltip = chart.tooltip;\n  const annotations = getElements(chart);\n  let offset = length * (now - realtime.head) / duration;\n  if (isHorizontal === !!scale.options.reverse) {\n    offset = -offset;\n  }\n  each(chart.data.datasets, (dataset, datasetIndex) => {\n    const meta = chart.getDatasetMeta(datasetIndex);\n    const {data: elements = [], dataset: element} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      transition(elements[i], id, offset);\n    }\n    if (element) {\n      transition(element, id, offset);\n      delete element._path;\n    }\n  });\n  for (let i = 0, ilen = annotations.length; i < ilen; ++i) {\n    transition(annotations[i], id, offset);\n  }\n  if (tooltip) {\n    transition(tooltip, id, offset);\n  }\n  scale.max = now - delay;\n  scale.min = scale.max - duration;\n  realtime.head = now;\n}\nclass RealTimeScale extends TimeScale {\n  constructor(props) {\n    super(props);\n    this.$realtime = this.$realtime || {};\n  }\n  init(scaleOpts, opts) {\n    const me = this;\n    super.init(scaleOpts, opts);\n    startDataRefreshTimer(me.$realtime, () => {\n      const chart = me.chart;\n      const onRefresh = resolveOption(me, 'onRefresh');\n      callback(onRefresh, [chart], me);\n      clean(me);\n      chart.update('quiet');\n      return resolveOption(me, 'refresh');\n    });\n  }\n  update(maxWidth, maxHeight, margins) {\n    const me = this;\n    const {$realtime: realtime, options} = me;\n    const {bounds, offset, ticks: ticksOpts} = options;\n    const {autoSkip, source, major: majorTicksOpts} = ticksOpts;\n    const majorEnabled = majorTicksOpts.enabled;\n    if (resolveOption(me, 'pause')) {\n      stopFrameRefreshTimer(realtime);\n    } else {\n      if (!realtime.frameRequestID) {\n        realtime.head = Date.now();\n      }\n      startFrameRefreshTimer(realtime, () => {\n        const chart = me.chart;\n        const streaming = chart.$streaming;\n        scroll(me);\n        if (streaming) {\n          callback(streaming.render, [chart]);\n        }\n        return resolveOption(me, 'frameRate');\n      });\n    }\n    options.bounds = undefined;\n    options.offset = false;\n    ticksOpts.autoSkip = false;\n    ticksOpts.source = source === 'auto' ? '' : source;\n    majorTicksOpts.enabled = true;\n    super.update(maxWidth, maxHeight, margins);\n    options.bounds = bounds;\n    options.offset = offset;\n    ticksOpts.autoSkip = autoSkip;\n    ticksOpts.source = source;\n    majorTicksOpts.enabled = majorEnabled;\n  }\n  buildTicks() {\n    const me = this;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const maxArray = [1e15, max];\n    const minArray = [-1e15, min];\n    Object.defineProperty(me, 'min', {\n      get: () => minArray.shift(),\n      set: noop\n    });\n    Object.defineProperty(me, 'max', {\n      get: () => maxArray.shift(),\n      set: noop\n    });\n    const ticks = super.buildTicks();\n    delete me.min;\n    delete me.max;\n    me.min = min;\n    me.max = max;\n    return ticks;\n  }\n  calculateLabelRotation() {\n    const ticksOpts = this.options.ticks;\n    const maxRotation = ticksOpts.maxRotation;\n    ticksOpts.maxRotation = ticksOpts.minRotation || 0;\n    super.calculateLabelRotation();\n    ticksOpts.maxRotation = maxRotation;\n  }\n  fit() {\n    const me = this;\n    const options = me.options;\n    super.fit();\n    if (options.ticks.display && options.display && me.isHorizontal()) {\n      me.paddingLeft = 3;\n      me.paddingRight = 3;\n      me._handleMargins();\n    }\n  }\n  draw(chartArea) {\n    const me = this;\n    const {chart, ctx} = me;\n    const area = me.isHorizontal() ?\n      {\n        left: chartArea.left,\n        top: 0,\n        right: chartArea.right,\n        bottom: chart.height\n      } : {\n        left: 0,\n        top: chartArea.top,\n        right: chart.width,\n        bottom: chartArea.bottom\n      };\n    me._gridLineItems = null;\n    me._labelItems = null;\n    clipArea(ctx, area);\n    super.draw(chartArea);\n    unclipArea(ctx);\n  }\n  destroy() {\n    const realtime = this.$realtime;\n    stopFrameRefreshTimer(realtime);\n    stopDataRefreshTimer(realtime);\n  }\n  _generate() {\n    const me = this;\n    const adapter = me._adapter;\n    const duration = resolveOption(me, 'duration');\n    const delay = resolveOption(me, 'delay');\n    const refresh = resolveOption(me, 'refresh');\n    const max = me.$realtime.head - delay;\n    const min = max - duration;\n    const capacity = me._getLabelCapacity(min);\n    const {time: timeOpts, ticks: ticksOpts} = me.options;\n    const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);\n    const major = determineMajorUnit(minor);\n    const stepSize = timeOpts.stepSize || determineStepSize(min, max, minor, capacity);\n    const weekday = minor === 'week' ? timeOpts.isoWeekday : false;\n    const majorTicksEnabled = ticksOpts.major.enabled;\n    const hasWeekday = isNumber(weekday) || weekday === true;\n    const interval = INTERVALS[minor];\n    const ticks = {};\n    let first = min;\n    let time, count;\n    if (hasWeekday) {\n      first = +adapter.startOf(first, 'isoWeek', weekday);\n    }\n    first = +adapter.startOf(first, hasWeekday ? 'day' : minor);\n    if (adapter.diff(max, min, minor) > 100000 * stepSize) {\n      throw new Error(min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor);\n    }\n    time = first;\n    if (majorTicksEnabled && major && !hasWeekday && !timeOpts.round) {\n      time = +adapter.startOf(time, major);\n      time = +adapter.add(time, ~~((first - time) / (interval.size * stepSize)) * stepSize, minor);\n    }\n    const timestamps = ticksOpts.source === 'data' && me.getDataTimestamps();\n    for (count = 0; time < max + refresh; time = +adapter.add(time, stepSize, minor), count++) {\n      addTick(ticks, time, timestamps);\n    }\n    if (time === max + refresh || count === 1) {\n      addTick(ticks, time, timestamps);\n    }\n    return Object.keys(ticks).sort((a, b) => a - b).map(x => +x);\n  }\n}\nRealTimeScale.id = 'realtime';\nRealTimeScale.defaults = {\n  bounds: 'data',\n  adapters: {},\n  time: {\n    parser: false,\n    unit: false,\n    round: false,\n    isoWeekday: false,\n    minUnit: 'millisecond',\n    displayFormats: {}\n  },\n  realtime: {},\n  ticks: {\n    autoSkip: false,\n    source: 'auto',\n    major: {\n      enabled: true\n    }\n  }\n};\ndefaults.describe('scale.realtime', {\n  _scriptable: name => name !== 'onRefresh'\n});\n\nvar version = \"2.0.0\";\n\ndefaults.set('transitions', {\n  quiet: {\n    animation: {\n      duration: 0\n    }\n  }\n});\nconst transitionKeys = {x: ['x', 'cp1x', 'cp2x'], y: ['y', 'cp1y', 'cp2y']};\nfunction update(mode) {\n  const me = this;\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      const controller = me.getDatasetMeta(datasetIndex).controller;\n      controller._setStyle = function(element, index, _mode, active) {\n        DatasetController.prototype._setStyle.call(this, element, index, 'quiet', active);\n      };\n    });\n  }\n  Chart.prototype.update.call(me, mode);\n  if (mode === 'quiet') {\n    each(me.data.datasets, (dataset, datasetIndex) => {\n      delete me.getDatasetMeta(datasetIndex).controller._setStyle;\n    });\n  }\n}\nfunction render(chart) {\n  const streaming = chart.$streaming;\n  chart.render();\n  if (streaming.lastMouseEvent) {\n    setTimeout(() => {\n      const lastMouseEvent = streaming.lastMouseEvent;\n      if (lastMouseEvent) {\n        chart._eventHandler(lastMouseEvent);\n      }\n    }, 0);\n  }\n}\nvar StreamingPlugin = {\n  id: 'streaming',\n  version,\n  beforeInit(chart) {\n    const streaming = chart.$streaming = chart.$streaming || {render};\n    const canvas = streaming.canvas = chart.canvas;\n    const mouseEventListener = streaming.mouseEventListener = event => {\n      const pos = getRelativePosition(event, chart);\n      streaming.lastMouseEvent = {\n        type: 'mousemove',\n        chart: chart,\n        native: event,\n        x: pos.x,\n        y: pos.y\n      };\n    };\n    canvas.addEventListener('mousedown', mouseEventListener);\n    canvas.addEventListener('mouseup', mouseEventListener);\n  },\n  afterInit(chart) {\n    chart.update = update;\n  },\n  beforeUpdate(chart) {\n    const {scales, elements} = chart.options;\n    const tooltip = chart.tooltip;\n    each(scales, ({type}) => {\n      if (type === 'realtime') {\n        elements.line.capBezierPoints = false;\n      }\n    });\n    if (tooltip) {\n      tooltip.update = update$1;\n    }\n    try {\n      const plugin = registry.getPlugin('annotation');\n      attachChart$1(plugin, chart);\n    } catch (e) {\n      detachChart$1(chart);\n    }\n    try {\n      const plugin = registry.getPlugin('zoom');\n      attachChart(plugin, chart);\n    } catch (e) {\n      detachChart(chart);\n    }\n  },\n  beforeDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    if (mode === 'quiet') {\n      const {controller, $animations} = meta;\n      if ($animations && $animations.visible && $animations.visible._active) {\n        controller.updateElement = noop;\n        controller.updateSharedOptions = noop;\n      }\n    }\n  },\n  afterDatasetUpdate(chart, args) {\n    const {meta, mode} = args;\n    const {data: elements = [], dataset: element, controller} = meta;\n    for (let i = 0, ilen = elements.length; i < ilen; ++i) {\n      elements[i].$streaming = getAxisMap(elements[i], transitionKeys, meta);\n    }\n    if (element) {\n      element.$streaming = getAxisMap(element, transitionKeys, meta);\n    }\n    if (mode === 'quiet') {\n      delete controller.updateElement;\n      delete controller.updateSharedOptions;\n    }\n  },\n  beforeDatasetDraw(chart, args) {\n    const {ctx, chartArea, width, height} = chart;\n    const {xAxisID, yAxisID, controller} = args.meta;\n    const area = {\n      left: 0,\n      top: 0,\n      right: width,\n      bottom: height\n    };\n    if (xAxisID && controller.getScaleForId(xAxisID) instanceof RealTimeScale) {\n      area.left = chartArea.left;\n      area.right = chartArea.right;\n    }\n    if (yAxisID && controller.getScaleForId(yAxisID) instanceof RealTimeScale) {\n      area.top = chartArea.top;\n      area.bottom = chartArea.bottom;\n    }\n    clipArea(ctx, area);\n  },\n  afterDatasetDraw(chart) {\n    unclipArea(chart.ctx);\n  },\n  beforeEvent(chart, args) {\n    const streaming = chart.$streaming;\n    const event = args.event;\n    if (event.type === 'mousemove') {\n      streaming.lastMouseEvent = event;\n    } else if (event.type === 'mouseout') {\n      delete streaming.lastMouseEvent;\n    }\n  },\n  destroy(chart) {\n    const {scales, $streaming: streaming, tooltip} = chart;\n    const {canvas, mouseEventListener} = streaming;\n    delete chart.update;\n    if (tooltip) {\n      delete tooltip.update;\n    }\n    canvas.removeEventListener('mousedown', mouseEventListener);\n    canvas.removeEventListener('mouseup', mouseEventListener);\n    each(scales, scale => {\n      if (scale instanceof RealTimeScale) {\n        scale.destroy();\n      }\n    });\n  },\n  defaults: {\n    duration: 10000,\n    delay: 0,\n    frameRate: 30,\n    refresh: 1000,\n    onRefresh: null,\n    pause: false,\n    ttl: undefined\n  },\n  descriptors: {\n    _scriptable: name => name !== 'onRefresh'\n  }\n};\n\nconst registerables = [StreamingPlugin, RealTimeScale];\n\nexport default registerables;\nexport { RealTimeScale, StreamingPlugin };\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAT,EAAmBC,SAAnB,EAA8BC,QAA9B,EAAwCC,iBAAxC,EAA2DC,KAA3D,QAAwE,UAAxE;AACA,SAASC,cAAT,EAAyBC,IAAzB,EAA+BC,gBAA/B,EAAiDC,QAAjD,EAA2DC,IAA3D,EAAiEC,QAAjE,EAA2EC,QAA3E,EAAqFC,UAArF,EAAiGC,QAAjG,EAA2GC,OAA3G,EAAoHC,OAApH,EAA6HC,mBAA7H,QAAwJ,kBAAxJ;;AAEA,SAASC,KAAT,CAAeC,KAAf,EAAsBC,KAAtB,EAA6BC,KAA7B,EAAoC;EAClC,OAAOC,IAAI,CAACC,GAAL,CAASD,IAAI,CAACE,GAAL,CAASL,KAAT,EAAgBC,KAAhB,CAAT,EAAiCC,KAAjC,CAAP;AACD;;AACD,SAASI,aAAT,CAAuBC,KAAvB,EAA8BC,GAA9B,EAAmC;EACjC,MAAMC,YAAY,GAAGF,KAAK,CAACG,OAAN,CAAcC,QAAnC;EACA,MAAMC,aAAa,GAAGL,KAAK,CAACM,KAAN,CAAYH,OAAZ,CAAoBI,OAApB,CAA4BC,SAAlD;EACA,OAAO5B,cAAc,CAACsB,YAAY,CAACD,GAAD,CAAb,EAAoBI,aAAa,CAACJ,GAAD,CAAjC,CAArB;AACD;;AACD,SAASQ,UAAT,CAAoBC,OAApB,eAAyD;EAAA,IAA5B;IAACC,CAAD;IAAIC;EAAJ,CAA4B;EAAA,IAApB;IAACC,OAAD;IAAUC;EAAV,CAAoB;EACvD,MAAMC,OAAO,GAAG,EAAhB;EACAlC,IAAI,CAAC8B,CAAD,EAAIV,GAAG,IAAI;IACbc,OAAO,CAACd,GAAD,CAAP,GAAe;MAACe,MAAM,EAAEH;IAAT,CAAf;EACD,CAFG,CAAJ;EAGAhC,IAAI,CAAC+B,CAAD,EAAIX,GAAG,IAAI;IACbc,OAAO,CAACd,GAAD,CAAP,GAAe;MAACe,MAAM,EAAEF;IAAT,CAAf;EACD,CAFG,CAAJ;EAGA,OAAOC,OAAP;AACD;;AACD,MAAME,eAAe,GAAI,YAAW;EAClC,IAAI,OAAOC,MAAP,KAAkB,WAAtB,EAAmC;IACjC,OAAOlC,IAAP;EACD;;EACD,OAAOkC,MAAM,CAACC,oBAAd;AACD,CALwB,EAAzB;;AAMA,SAASC,sBAAT,CAAgCC,OAAhC,EAAyCC,IAAzC,EAA+C;EAC7C,IAAI,CAACD,OAAO,CAACE,cAAb,EAA6B;IAC3B,MAAMC,OAAO,GAAG,MAAM;MACpB,MAAMC,WAAW,GAAGJ,OAAO,CAACI,WAAR,IAAuB,CAA3C;MACA,MAAMC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;;MACA,IAAID,WAAW,IAAIC,GAAnB,EAAwB;QACtB,MAAME,YAAY,GAAG7C,QAAQ,CAACuC,IAAD,CAA7B;QACA,MAAMO,aAAa,GAAG,QAAQjC,IAAI,CAACE,GAAL,CAAS8B,YAAT,EAAuB,CAAvB,KAA6B,EAArC,CAAtB;QACA,MAAME,cAAc,GAAGT,OAAO,CAACI,WAAR,GAAsBI,aAAtB,IAAuC,CAA9D;QACAR,OAAO,CAACI,WAAR,GAAsBK,cAAc,GAAGJ,GAAjB,GAAuBI,cAAvB,GAAwCJ,GAAG,GAAGG,aAApE;MACD;;MACDR,OAAO,CAACE,cAAR,GAAyBzC,gBAAgB,CAACiD,IAAjB,CAAsBb,MAAtB,EAA8BM,OAA9B,CAAzB;IACD,CAVD;;IAWAH,OAAO,CAACE,cAAR,GAAyBzC,gBAAgB,CAACiD,IAAjB,CAAsBb,MAAtB,EAA8BM,OAA9B,CAAzB;EACD;AACF;;AACD,SAASQ,qBAAT,CAA+BX,OAA/B,EAAwC;EACtC,MAAME,cAAc,GAAGF,OAAO,CAACE,cAA/B;;EACA,IAAIA,cAAJ,EAAoB;IAClBN,eAAe,CAACc,IAAhB,CAAqBb,MAArB,EAA6BK,cAA7B;IACA,OAAOF,OAAO,CAACE,cAAf;EACD;AACF;;AACD,SAASU,oBAAT,CAA8BZ,OAA9B,EAAuC;EACrC,MAAMa,cAAc,GAAGb,OAAO,CAACa,cAA/B;;EACA,IAAIA,cAAJ,EAAoB;IAClBC,aAAa,CAACD,cAAD,CAAb;IACA,OAAOb,OAAO,CAACa,cAAf;IACA,OAAOb,OAAO,CAACe,eAAf;EACD;AACF;;AACD,SAASC,qBAAT,CAA+BhB,OAA/B,EAAwCC,IAAxC,EAA8CgB,QAA9C,EAAwD;EACtD,IAAI,CAACjB,OAAO,CAACa,cAAb,EAA6B;IAC3Bb,OAAO,CAACa,cAAR,GAAyBK,WAAW,CAAC,MAAM;MACzC,MAAMC,WAAW,GAAGzD,QAAQ,CAACuC,IAAD,CAA5B;;MACA,IAAID,OAAO,CAACe,eAAR,KAA4BI,WAA5B,IAA2C,CAACC,KAAK,CAACD,WAAD,CAArD,EAAoE;QAClEP,oBAAoB,CAACZ,OAAD,CAApB;QACAgB,qBAAqB,CAAChB,OAAD,EAAUC,IAAV,EAAgBkB,WAAhB,CAArB;MACD;IACF,CANmC,EAMjCF,QAAQ,IAAI,CANqB,CAApC;IAOAjB,OAAO,CAACe,eAAR,GAA0BE,QAAQ,IAAI,CAAtC;EACD;AACF;;AAED,SAASI,UAAT,CAAoB1C,KAApB,EAA2BP,KAA3B,EAAkCkD,QAAlC,EAA4C;EAC1ClD,KAAK,GAAG,OAAOA,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCO,KAAK,CAAC4C,KAAN,CAAYnD,KAAZ,CAA5C;EACA,OAAOR,QAAQ,CAACQ,KAAD,CAAR,GACL;IAACA,KAAK,EAAEO,KAAK,CAAC6C,gBAAN,CAAuBpD,KAAvB,CAAR;IAAuCqD,cAAc,EAAE;EAAvD,CADK,GAEL;IAACrD,KAAK,EAAEkD;EAAR,CAFF;AAGD;;AACD,SAASI,mBAAT,CAA6BrC,OAA7B,EAAsCJ,KAAtC,EAA6CH,OAA7C,EAAsD;EACpD,MAAM;IAAC6C,MAAD;IAASC;EAAT,IAAsB3C,KAA5B;EACA,MAAM;IAAC4C,QAAD;IAAWC,QAAX;IAAqBC,IAArB;IAA2BC,IAA3B;IAAiCC,IAAjC;IAAuCC;EAAvC,IAA+CpD,OAArD;EACA,MAAMqD,MAAM,GAAGR,MAAM,CAACE,QAAD,CAArB;EACA,MAAMO,MAAM,GAAGT,MAAM,CAACG,QAAD,CAArB;EACA,MAAM;IAACO,GAAD;IAAMC,IAAN;IAAYC,MAAZ;IAAoBC;EAApB,IAA6BZ,SAAnC;EACA,MAAMzC,SAAS,GAAGE,OAAO,CAACoD,UAAR,GAAqB,EAAvC;;EACA,IAAIN,MAAJ,EAAY;IACV,MAAM3D,GAAG,GAAG6C,UAAU,CAACc,MAAD,EAASJ,IAAT,EAAeO,IAAf,CAAtB;IACA,MAAM7D,GAAG,GAAG4C,UAAU,CAACc,MAAD,EAASH,IAAT,EAAeQ,KAAf,CAAtB;IACA,MAAME,OAAO,GAAGlE,GAAG,CAACJ,KAAJ,GAAYK,GAAG,CAACL,KAAhC;;IACA,IAAII,GAAG,CAACiD,cAAR,EAAwB;MACtBtC,SAAS,CAACuD,OAAO,GAAG,IAAH,GAAU,GAAlB,CAAT,GAAkC;QAAC/C,MAAM,EAAEkC;MAAT,CAAlC;IACD;;IACD,IAAIpD,GAAG,CAACgD,cAAR,EAAwB;MACtBtC,SAAS,CAACuD,OAAO,GAAG,GAAH,GAAS,IAAjB,CAAT,GAAkC;QAAC/C,MAAM,EAAEkC;MAAT,CAAlC;IACD;;IACD,IAAIrD,GAAG,CAACiD,cAAJ,KAAuBhD,GAAG,CAACgD,cAA/B,EAA+C;MAC7CtC,SAAS,CAACwD,KAAV,GAAkB;QAAChD,MAAM,EAAEkC,QAAT;QAAmBa,OAAO,EAAElE,GAAG,CAACiD;MAAhC,CAAlB;IACD;EACF;;EACD,IAAIW,MAAJ,EAAY;IACV,MAAM5D,GAAG,GAAG6C,UAAU,CAACe,MAAD,EAASH,IAAT,EAAeI,GAAf,CAAtB;IACA,MAAM5D,GAAG,GAAG4C,UAAU,CAACe,MAAD,EAASF,IAAT,EAAeK,MAAf,CAAtB;IACA,MAAMG,OAAO,GAAGlE,GAAG,CAACJ,KAAJ,GAAYK,GAAG,CAACL,KAAhC;;IACA,IAAII,GAAG,CAACiD,cAAR,EAAwB;MACtBtC,SAAS,CAACuD,OAAO,GAAG,IAAH,GAAU,GAAlB,CAAT,GAAkC;QAAC/C,MAAM,EAAEmC;MAAT,CAAlC;IACD;;IACD,IAAIrD,GAAG,CAACgD,cAAR,EAAwB;MACtBtC,SAAS,CAACuD,OAAO,GAAG,GAAH,GAAS,IAAjB,CAAT,GAAkC;QAAC/C,MAAM,EAAEmC;MAAT,CAAlC;IACD;;IACD,IAAItD,GAAG,CAACiD,cAAJ,KAAuBhD,GAAG,CAACgD,cAA/B,EAA+C;MAC7CtC,SAAS,CAACyD,MAAV,GAAmB;QAACjD,MAAM,EAAEmC,QAAT;QAAmBY,OAAO,EAAElE,GAAG,CAACiD;MAAhC,CAAnB;IACD;EACF;AACF;;AACD,SAASoB,oBAAT,CAA8BxD,OAA9B,EAAuCJ,KAAvC,EAA8CH,OAA9C,EAAuD;EACrD,MAAM;IAAC6C,MAAD;IAASC;EAAT,IAAsB3C,KAA5B;EACA,MAAM;IAAC6D,OAAD;IAAU1E;EAAV,IAAmBU,OAAzB;EACA,MAAMH,KAAK,GAAGgD,MAAM,CAACmB,OAAD,CAApB;EACA,MAAM;IAACT,GAAD;IAAMC,IAAN;IAAYC,MAAZ;IAAoBC;EAApB,IAA6BZ,SAAnC;EACA,MAAMzC,SAAS,GAAGE,OAAO,CAACoD,UAAR,GAAqB,EAAvC;;EACA,IAAI9D,KAAJ,EAAW;IACT,MAAMoE,YAAY,GAAGpE,KAAK,CAACoE,YAAN,EAArB;IACA,MAAMC,KAAK,GAAG3B,UAAU,CAAC1C,KAAD,EAAQP,KAAR,CAAxB;;IACA,IAAI4E,KAAK,CAACvB,cAAV,EAA0B;MACxBtC,SAAS,CAAC4D,YAAY,GAAG,GAAH,GAAS,GAAtB,CAAT,GAAsC;QAACpD,MAAM,EAAEmD;MAAT,CAAtC;MACA3D,SAAS,CAAC4D,YAAY,GAAG,IAAH,GAAU,IAAvB,CAAT,GAAwC;QAACpD,MAAM,EAAEmD;MAAT,CAAxC;IACD;;IACD,OAAOC,YAAY,GAAG;MAACV,GAAD;MAAME;IAAN,CAAH,GAAmB;MAACD,IAAD;MAAOE;IAAP,CAAtC;EACD;;EACD,MAAM;IAACX,QAAD;IAAWC,QAAX;IAAqBC,IAArB;IAA2BC,IAA3B;IAAiCC,IAAjC;IAAuCC;EAAvC,IAA+CpD,OAArD;EACA,MAAMqD,MAAM,GAAGR,MAAM,CAACE,QAAD,CAArB;EACA,MAAMO,MAAM,GAAGT,MAAM,CAACG,QAAD,CAArB;EACA,MAAMmB,IAAI,GAAG,EAAb;;EACA,IAAId,MAAJ,EAAY;IACV,MAAM3D,GAAG,GAAG6C,UAAU,CAACc,MAAD,EAASJ,IAAT,CAAtB;IACA,MAAMtD,GAAG,GAAG4C,UAAU,CAACc,MAAD,EAASH,IAAT,CAAtB;;IACA,IAAIxD,GAAG,CAACiD,cAAR,EAAwB;MACtBtC,SAAS,CAACG,CAAV,GAAc;QAACK,MAAM,EAAEkC;MAAT,CAAd;IACD,CAFD,MAEO;MACLoB,IAAI,CAACX,IAAL,GAAYA,IAAZ;IACD;;IACD,IAAI7D,GAAG,CAACgD,cAAR,EAAwB;MACtBtC,SAAS,CAAC+D,EAAV,GAAe;QAACvD,MAAM,EAAEkC;MAAT,CAAf;IACD,CAFD,MAEO;MACLoB,IAAI,CAACT,KAAL,GAAaA,KAAb;IACD;EACF;;EACD,IAAIJ,MAAJ,EAAY;IACV,MAAM5D,GAAG,GAAG6C,UAAU,CAACe,MAAD,EAASH,IAAT,CAAtB;IACA,MAAMxD,GAAG,GAAG4C,UAAU,CAACe,MAAD,EAASF,IAAT,CAAtB;;IACA,IAAI1D,GAAG,CAACiD,cAAR,EAAwB;MACtBtC,SAAS,CAACI,CAAV,GAAc;QAACI,MAAM,EAAEmC;MAAT,CAAd;IACD,CAFD,MAEO;MACLmB,IAAI,CAACZ,GAAL,GAAWA,GAAX;IACD;;IACD,IAAI5D,GAAG,CAACgD,cAAR,EAAwB;MACtBtC,SAAS,CAACgE,EAAV,GAAe;QAACxD,MAAM,EAAEmC;MAAT,CAAf;IACD,CAFD,MAEO;MACLmB,IAAI,CAACV,MAAL,GAAcA,MAAd;IACD;EACF;;EACD,OAAOU,IAAP;AACD;;AACD,SAASG,qBAAT,CAA+B/D,OAA/B,EAAwCJ,KAAxC,EAA+CH,OAA/C,EAAwD;EACtD,MAAM6C,MAAM,GAAG1C,KAAK,CAAC0C,MAArB;EACA,MAAM;IAACE,QAAD;IAAWC,QAAX;IAAqBuB,MAArB;IAA6BC;EAA7B,IAAuCxE,OAA7C;EACA,MAAMqD,MAAM,GAAGR,MAAM,CAACE,QAAD,CAArB;EACA,MAAMO,MAAM,GAAGT,MAAM,CAACG,QAAD,CAArB;EACA,MAAM3C,SAAS,GAAGE,OAAO,CAACoD,UAAR,GAAqB,EAAvC;;EACA,IAAIN,MAAJ,EAAY;IACV,MAAM7C,CAAC,GAAG+B,UAAU,CAACc,MAAD,EAASkB,MAAT,CAApB;;IACA,IAAI/D,CAAC,CAACmC,cAAN,EAAsB;MACpBtC,SAAS,CAACG,CAAV,GAAc;QAACK,MAAM,EAAEkC;MAAT,CAAd;IACD;EACF;;EACD,IAAIO,MAAJ,EAAY;IACV,MAAM7C,CAAC,GAAG8B,UAAU,CAACe,MAAD,EAASkB,MAAT,CAApB;;IACA,IAAI/D,CAAC,CAACkC,cAAN,EAAsB;MACpBtC,SAAS,CAACI,CAAV,GAAc;QAACI,MAAM,EAAEmC;MAAT,CAAd;IACD;EACF;AACF;;AACD,SAASyB,oBAAT,GAAgC;EAC9B,MAAMC,aAAa,GAAGtG,QAAQ,CAACuG,UAAT,CAAoB,eAApB,CAAtB;EACA,MAAMC,cAAc,GAAGxG,QAAQ,CAACuG,UAAT,CAAoB,gBAApB,CAAvB;EACA,MAAME,eAAe,GAAGzG,QAAQ,CAACuG,UAAT,CAAoB,iBAApB,CAAxB;EACA,MAAMG,8BAA8B,GAAGJ,aAAa,CAACK,SAAd,CAAwBC,wBAA/D;EACA,MAAMC,+BAA+B,GAAGL,cAAc,CAACG,SAAf,CAAyBC,wBAAjE;EACA,MAAME,gCAAgC,GAAGL,eAAe,CAACE,SAAhB,CAA0BC,wBAAnE;;EACAN,aAAa,CAACK,SAAd,CAAwBC,wBAAxB,GAAmD,UAAS7E,KAAT,EAAgBH,OAAhB,EAAyB;IAC1E4C,mBAAmB,CAAC,IAAD,EAAOzC,KAAP,EAAcH,OAAd,CAAnB;IACA,OAAO8E,8BAA8B,CAAClD,IAA/B,CAAoC,IAApC,EAA0CzB,KAA1C,EAAiDH,OAAjD,CAAP;EACD,CAHD;;EAIA4E,cAAc,CAACG,SAAf,CAAyBC,wBAAzB,GAAoD,UAAS7E,KAAT,EAAgBH,OAAhB,EAAyB;IAC3E,MAAM8C,SAAS,GAAG3C,KAAK,CAAC2C,SAAxB;IACA3C,KAAK,CAAC2C,SAAN,GAAkBiB,oBAAoB,CAAC,IAAD,EAAO5D,KAAP,EAAcH,OAAd,CAAtC;IACA,MAAMmF,UAAU,GAAGF,+BAA+B,CAACrD,IAAhC,CAAqC,IAArC,EAA2CzB,KAA3C,EAAkDH,OAAlD,CAAnB;IACAG,KAAK,CAAC2C,SAAN,GAAkBA,SAAlB;IACA,OAAOqC,UAAP;EACD,CAND;;EAOAN,eAAe,CAACE,SAAhB,CAA0BC,wBAA1B,GAAqD,UAAS7E,KAAT,EAAgBH,OAAhB,EAAyB;IAC5EsE,qBAAqB,CAAC,IAAD,EAAOnE,KAAP,EAAcH,OAAd,CAArB;IACA,OAAOkF,gCAAgC,CAACtD,IAAjC,CAAsC,IAAtC,EAA4CzB,KAA5C,EAAmDH,OAAnD,CAAP;EACD,CAHD;AAID;;AACD,SAASoF,aAAT,CAAuBC,MAAvB,EAA+BlF,KAA/B,EAAsC;EACpC,MAAME,SAAS,GAAGF,KAAK,CAACwD,UAAxB;;EACA,IAAItD,SAAS,CAACiF,gBAAV,KAA+BD,MAAnC,EAA2C;IACzC,MAAME,WAAW,GAAGF,MAAM,CAACE,WAA3B;IACAd,oBAAoB;IACpBpE,SAAS,CAACiF,gBAAV,GAA6BD,MAA7B;;IACAA,MAAM,CAACE,WAAP,GAAqB,CAACC,MAAD,EAASC,IAAT,EAAezF,OAAf,KAA2B;MAC9C,MAAM0F,IAAI,GAAGD,IAAI,CAACC,IAAlB;MACA,MAAMC,aAAa,GAAG3F,OAAO,CAAC4F,SAA9B;;MACA,IAAIF,IAAI,KAAK,OAAb,EAAsB;QACpB1F,OAAO,CAAC4F,SAAR,GAAoB,KAApB;MACD;;MACDL,WAAW,CAAC3D,IAAZ,CAAiB,IAAjB,EAAuB4D,MAAvB,EAA+BC,IAA/B,EAAqCzF,OAArC;;MACA,IAAI0F,IAAI,KAAK,OAAb,EAAsB;QACpB1F,OAAO,CAAC4F,SAAR,GAAoBD,aAApB;MACD;IACF,CAVD;EAWD;AACF;;AACD,SAASE,WAAT,CAAqB1F,KAArB,EAA4B;EAC1B,MAAMkF,MAAM,GAAGlF,KAAK,CAACwD,UAAN,CAAiB2B,gBAAhC;;EACA,IAAID,MAAJ,EAAY;IACV,MAAMS,KAAK,GAAGT,MAAM,CAACU,SAAP,CAAiB5F,KAAjB,CAAd;;IACA,OAAO2F,KAAK,IAAIA,KAAK,CAACE,QAAf,IAA2B,EAAlC;EACD;;EACD,OAAO,EAAP;AACD;;AACD,SAASC,aAAT,CAAuB9F,KAAvB,EAA8B;EAC5B,OAAOA,KAAK,CAACwD,UAAN,CAAiB2B,gBAAxB;AACD;;AAED,MAAMY,gBAAgB,GAAG;EAAC1F,CAAC,EAAE,CAAC,GAAD,EAAM,QAAN,CAAJ;EAAqBC,CAAC,EAAE,CAAC,GAAD,EAAM,QAAN;AAAxB,CAAzB;;AACA,SAAS0F,QAAT,GAA2B;EACzB,MAAMC,EAAE,GAAG,IAAX;EACA,MAAM7F,OAAO,GAAG6F,EAAE,CAACC,iBAAH,GAAuB,CAAvB,CAAhB;;EACA,IAAI9F,OAAJ,EAAa;IACX,MAAM+F,IAAI,GAAGF,EAAE,CAACZ,MAAH,CAAUe,cAAV,CAAyBhG,OAAO,CAACiG,YAAjC,CAAb;;IACAJ,EAAE,CAACzC,UAAH,GAAgBrD,UAAU,CAAC8F,EAAD,EAAKF,gBAAL,EAAuBI,IAAvB,CAA1B;EACD,CAHD,MAGO;IACLF,EAAE,CAACzC,UAAH,GAAgB,EAAhB;EACD;;EARwB,kCAAN8B,IAAM;IAANA,IAAM;EAAA;;EASzBW,EAAE,CAACK,WAAH,CAAe1B,SAAf,CAAyB2B,MAAzB,CAAgC9E,IAAhC,CAAqCwE,EAArC,EAAyC,GAAGX,IAA5C;AACD;;AAED,MAAMkB,WAAW,GAAG,IAAIC,OAAJ,EAApB;;AACA,SAASC,QAAT,CAAkB1G,KAAlB,EAAyB;EACvB,IAAI2F,KAAK,GAAGa,WAAW,CAACG,GAAZ,CAAgB3G,KAAhB,CAAZ;;EACA,IAAI,CAAC2F,KAAL,EAAY;IACVA,KAAK,GAAG;MAACiB,oBAAoB,EAAE;IAAvB,CAAR;IACAJ,WAAW,CAACK,GAAZ,CAAgB7G,KAAhB,EAAuB2F,KAAvB;EACD;;EACD,OAAOA,KAAP;AACD;;AACD,SAASmB,WAAT,CAAqB9G,KAArB,EAA4B;EAC1BwG,WAAW,CAACO,MAAZ,CAAmB/G,KAAnB;AACD;;AACD,SAASgH,yBAAT,CAAmChH,KAAnC,EAA0C;EACxC,MAAM;IAAC4G;EAAD,IAAyBF,QAAQ,CAAC1G,KAAD,CAAvC;EACA,MAAM0C,MAAM,GAAG1C,KAAK,CAAC0C,MAArB;EACAnE,IAAI,CAACmE,MAAD,EAAShD,KAAK,IAAI;IACpB,MAAMuH,EAAE,GAAGvH,KAAK,CAACuH,EAAjB;;IACA,IAAI,CAACL,oBAAoB,CAACK,EAAD,CAAzB,EAA+B;MAC7BL,oBAAoB,CAACK,EAAD,CAApB,GAA2B;QACzBC,QAAQ,EAAEzH,aAAa,CAACC,KAAD,EAAQ,UAAR,CADE;QAEzByH,KAAK,EAAE1H,aAAa,CAACC,KAAD,EAAQ,OAAR;MAFK,CAA3B;IAID;EACF,CARG,CAAJ;EASAnB,IAAI,CAACqI,oBAAD,EAAuB,CAACQ,GAAD,EAAMzH,GAAN,KAAc;IACvC,IAAI,CAAC+C,MAAM,CAAC/C,GAAD,CAAX,EAAkB;MAChB,OAAOiH,oBAAoB,CAACjH,GAAD,CAA3B;IACD;EACF,CAJG,CAAJ;EAKA,OAAOiH,oBAAP;AACD;;AACD,SAASS,iBAAT,CAA2B3H,KAA3B,EAAkC4H,IAAlC,EAAwCC,MAAxC,EAAgDC,MAAhD,EAAwD;EACtD,MAAM;IAACxH,KAAD;IAAQyH;EAAR,IAAgB/H,KAAtB;EACA,MAAM;IAACgI,WAAW,GAAG,CAAf;IAAkBC,WAAW,GAAGC,QAAhC;IAA0CC,QAAQ,GAAG,CAACD,QAAtD;IAAgEE,QAAQ,GAAGF;EAA3E,IAAuFJ,MAAM,IAAIA,MAAM,CAACC,IAAD,CAAhB,IAA0B,EAAvH;EACA,MAAM7H,YAAY,GAAGF,KAAK,CAACG,OAAN,CAAcC,QAAnC;EACA,MAAMoH,QAAQ,GAAGzH,aAAa,CAACC,KAAD,EAAQ,UAAR,CAA9B;EACA,MAAMyH,KAAK,GAAG1H,aAAa,CAACC,KAAD,EAAQ,OAAR,CAA3B;EACA,MAAMqI,WAAW,GAAG7I,KAAK,CAACgI,QAAQ,IAAI,IAAII,IAAR,CAAT,EAAwBI,WAAxB,EAAqCC,WAArC,CAAzB;EACA,IAAIK,UAAJ,EAAgBC,QAAhB;EACAjB,yBAAyB,CAAChH,KAAD,CAAzB;;EACA,IAAIN,KAAK,CAACoE,YAAN,EAAJ,EAA0B;IACxBkE,UAAU,GAAG,CAACtI,KAAK,CAAC6D,KAAN,GAAcgE,MAAM,CAAClH,CAAtB,KAA4BX,KAAK,CAAC6D,KAAN,GAAc7D,KAAK,CAAC2D,IAAhD,CAAb;EACD,CAFD,MAEO;IACL2E,UAAU,GAAG,CAACtI,KAAK,CAAC4D,MAAN,GAAeiE,MAAM,CAACjH,CAAvB,KAA6BZ,KAAK,CAAC4D,MAAN,GAAe5D,KAAK,CAAC0D,GAAlD,CAAb;EACD;;EACD6E,QAAQ,GAAGd,KAAK,GAAGa,UAAU,IAAId,QAAQ,GAAGa,WAAf,CAA7B;EACAnI,YAAY,CAACsH,QAAb,GAAwBa,WAAxB;EACAnI,YAAY,CAACuH,KAAb,GAAqBjI,KAAK,CAAC+I,QAAD,EAAWJ,QAAX,EAAqBC,QAArB,CAA1B;EACA,OAAOC,WAAW,KAAKrI,KAAK,CAACF,GAAN,GAAYE,KAAK,CAACH,GAAzC;AACD;;AACD,SAAS2I,gBAAT,CAA0BxI,KAA1B,EAAiCyI,KAAjC,EAAwCX,MAAxC,EAAgD;EAC9C,MAAM;IAACxH,KAAD;IAAQyH;EAAR,IAAgB/H,KAAtB;EACA,MAAM;IAACmI,QAAQ,GAAG,CAACD,QAAb;IAAuBE,QAAQ,GAAGF;EAAlC,IAA8CJ,MAAM,IAAIA,MAAM,CAACC,IAAD,CAAhB,IAA0B,EAA9E;EACA,MAAMN,KAAK,GAAG1H,aAAa,CAACC,KAAD,EAAQ,OAAR,CAA3B;EACA,MAAMuI,QAAQ,GAAGd,KAAK,IAAIzH,KAAK,CAAC0I,gBAAN,CAAuBD,KAAvB,IAAgCzI,KAAK,CAAC0I,gBAAN,CAAuB,CAAvB,CAApC,CAAtB;EACApB,yBAAyB,CAAChH,KAAD,CAAzB;EACAN,KAAK,CAACG,OAAN,CAAcC,QAAd,CAAuBqH,KAAvB,GAA+BjI,KAAK,CAAC+I,QAAD,EAAWJ,QAAX,EAAqBC,QAArB,CAApC;EACA,OAAO,IAAP;AACD;;AACD,SAASO,yBAAT,CAAmCrI,KAAnC,EAA0C;EACxC,MAAM4G,oBAAoB,GAAGI,yBAAyB,CAAChH,KAAD,CAAtD;EACAzB,IAAI,CAACyB,KAAK,CAAC0C,MAAP,EAAehD,KAAK,IAAI;IAC1B,MAAM4I,eAAe,GAAG5I,KAAK,CAACG,OAAN,CAAcC,QAAtC;;IACA,IAAIwI,eAAJ,EAAqB;MACnB,MAAMC,QAAQ,GAAG3B,oBAAoB,CAAClH,KAAK,CAACuH,EAAP,CAArC;;MACA,IAAIsB,QAAJ,EAAc;QACZD,eAAe,CAACpB,QAAhB,GAA2BqB,QAAQ,CAACrB,QAApC;QACAoB,eAAe,CAACnB,KAAhB,GAAwBoB,QAAQ,CAACpB,KAAjC;MACD,CAHD,MAGO;QACL,OAAOmB,eAAe,CAACpB,QAAvB;QACA,OAAOoB,eAAe,CAACnB,KAAvB;MACD;IACF;EACF,CAZG,CAAJ;AAaD;;AACD,SAASqB,cAAT,CAAwBtD,MAAxB,EAAgC;EAC9BA,MAAM,CAACuD,aAAP,CAAqB3I,QAArB,GAAgCuH,iBAAhC;EACAnC,MAAM,CAACwD,YAAP,CAAoB5I,QAApB,GAA+BoI,gBAA/B;AACD;;AACD,SAASS,WAAT,CAAqBzD,MAArB,EAA6BlF,KAA7B,EAAoC;EAClC,MAAME,SAAS,GAAGF,KAAK,CAACwD,UAAxB;;EACA,IAAItD,SAAS,CAAC0I,UAAV,KAAyB1D,MAA7B,EAAqC;IACnC,MAAM2D,SAAS,GAAG3I,SAAS,CAAC2I,SAAV,GAAsB7I,KAAK,CAAC6I,SAA9C;IACAL,cAAc,CAACtD,MAAD,CAAd;;IACAlF,KAAK,CAAC6I,SAAN,GAAkBC,UAAU,IAAI;MAC9BT,yBAAyB,CAACrI,KAAD,CAAzB;MACA6I,SAAS,CAACC,UAAD,CAAT;IACD,CAHD;;IAIA5I,SAAS,CAAC0I,UAAV,GAAuB1D,MAAvB;EACD;AACF;;AACD,SAAS6D,WAAT,CAAqB/I,KAArB,EAA4B;EAC1B,MAAME,SAAS,GAAGF,KAAK,CAACwD,UAAxB;;EACA,IAAItD,SAAS,CAAC0I,UAAd,EAA0B;IACxB5I,KAAK,CAAC6I,SAAN,GAAkB3I,SAAS,CAAC2I,SAA5B;IACA/B,WAAW,CAAC9G,KAAD,CAAX;IACA,OAAOE,SAAS,CAAC2I,SAAjB;IACA,OAAO3I,SAAS,CAAC0I,UAAjB;EACD;AACF;;AAED,MAAMI,SAAS,GAAG;EAChBC,WAAW,EAAE;IACXC,MAAM,EAAE,IADG;IAEXC,IAAI,EAAE,CAFK;IAGXC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAc,EAAd,EAAkB,EAAlB,EAAsB,GAAtB,EAA2B,GAA3B,EAAgC,GAAhC;EAHI,CADG;EAMhBC,MAAM,EAAE;IACNH,MAAM,EAAE,IADF;IAENC,IAAI,EAAE,IAFA;IAGNC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAc,EAAd,EAAkB,EAAlB;EAHD,CANQ;EAWhBE,MAAM,EAAE;IACNJ,MAAM,EAAE,IADF;IAENC,IAAI,EAAE,KAFA;IAGNC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,EAAV,EAAc,EAAd,EAAkB,EAAlB;EAHD,CAXQ;EAgBhBG,IAAI,EAAE;IACJL,MAAM,EAAE,IADJ;IAEJC,IAAI,EAAE,OAFF;IAGJC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV,EAAa,EAAb;EAHH,CAhBU;EAqBhBI,GAAG,EAAE;IACHN,MAAM,EAAE,IADL;IAEHC,IAAI,EAAE,QAFH;IAGHC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;EAHJ,CArBW;EA0BhBK,IAAI,EAAE;IACJP,MAAM,EAAE,KADJ;IAEJC,IAAI,EAAE,SAFF;IAGJC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV;EAHH,CA1BU;EA+BhBM,KAAK,EAAE;IACLR,MAAM,EAAE,IADH;IAELC,IAAI,EAAE,OAFD;IAGLC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP;EAHF,CA/BS;EAoChBO,OAAO,EAAE;IACPT,MAAM,EAAE,KADD;IAEPC,IAAI,EAAE,OAFC;IAGPC,KAAK,EAAE,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,EAAU,CAAV;EAHA,CApCO;EAyChBQ,IAAI,EAAE;IACJV,MAAM,EAAE,IADJ;IAEJC,IAAI,EAAE;EAFF;AAzCU,CAAlB;AA8CA,MAAMU,KAAK,GAAGC,MAAM,CAACC,IAAP,CAAYf,SAAZ,CAAd;;AACA,SAASgB,iBAAT,CAA2BzK,GAA3B,EAAgCC,GAAhC,EAAqCyK,IAArC,EAA2CC,QAA3C,EAAqD;EACnD,MAAMC,KAAK,GAAG3K,GAAG,GAAGD,GAApB;EACA,MAAM;IAAC4J,IAAI,EAAEiB,YAAP;IAAqBhB;EAArB,IAA8BJ,SAAS,CAACiB,IAAD,CAA7C;EACA,IAAII,MAAJ;;EACA,IAAI,CAACjB,KAAL,EAAY;IACV,OAAO9J,IAAI,CAACgL,IAAL,CAAUH,KAAK,IAAID,QAAQ,GAAGE,YAAf,CAAf,CAAP;EACD;;EACD,KAAK,IAAIG,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAGpB,KAAK,CAACqB,MAA7B,EAAqCF,CAAC,GAAGC,IAAzC,EAA+C,EAAED,CAAjD,EAAoD;IAClDF,MAAM,GAAGjB,KAAK,CAACmB,CAAD,CAAd;;IACA,IAAIjL,IAAI,CAACgL,IAAL,CAAUH,KAAK,IAAIC,YAAY,GAAGC,MAAnB,CAAf,KAA8CH,QAAlD,EAA4D;MAC1D;IACD;EACF;;EACD,OAAOG,MAAP;AACD;;AACD,SAASK,yBAAT,CAAmCC,OAAnC,EAA4CpL,GAA5C,EAAiDC,GAAjD,EAAsD0K,QAAtD,EAAgE;EAC9D,MAAMC,KAAK,GAAG3K,GAAG,GAAGD,GAApB;EACA,MAAMiL,IAAI,GAAGX,KAAK,CAACY,MAAnB;;EACA,KAAK,IAAIF,CAAC,GAAGV,KAAK,CAACe,OAAN,CAAcD,OAAd,CAAb,EAAqCJ,CAAC,GAAGC,IAAI,GAAG,CAAhD,EAAmD,EAAED,CAArD,EAAwD;IACtD,MAAM;MAACrB,MAAD;MAASC,IAAT;MAAeC;IAAf,IAAwBJ,SAAS,CAACa,KAAK,CAACU,CAAD,CAAN,CAAvC;IACA,MAAMF,MAAM,GAAGjB,KAAK,GAAGA,KAAK,CAACA,KAAK,CAACqB,MAAN,GAAe,CAAhB,CAAR,GAA6BI,MAAM,CAACC,gBAAxD;;IACA,IAAI5B,MAAM,IAAI5J,IAAI,CAACgL,IAAL,CAAUH,KAAK,IAAIE,MAAM,GAAGlB,IAAb,CAAf,KAAsCe,QAApD,EAA8D;MAC5D,OAAOL,KAAK,CAACU,CAAD,CAAZ;IACD;EACF;;EACD,OAAOV,KAAK,CAACW,IAAI,GAAG,CAAR,CAAZ;AACD;;AACD,SAASO,kBAAT,CAA4Bd,IAA5B,EAAkC;EAChC,KAAK,IAAIM,CAAC,GAAGV,KAAK,CAACe,OAAN,CAAcX,IAAd,IAAsB,CAA9B,EAAiCO,IAAI,GAAGX,KAAK,CAACY,MAAnD,EAA2DF,CAAC,GAAGC,IAA/D,EAAqE,EAAED,CAAvE,EAA0E;IACxE,IAAIvB,SAAS,CAACa,KAAK,CAACU,CAAD,CAAN,CAAT,CAAoBrB,MAAxB,EAAgC;MAC9B,OAAOW,KAAK,CAACU,CAAD,CAAZ;IACD;EACF;AACF;;AACD,SAASS,OAAT,CAAiBC,KAAjB,EAAwBC,IAAxB,EAA8BC,UAA9B,EAA0C;EACxC,IAAI,CAACA,UAAL,EAAiB;IACfF,KAAK,CAACC,IAAD,CAAL,GAAc,IAAd;EACD,CAFD,MAEO,IAAIC,UAAU,CAACV,MAAf,EAAuB;IAC5B,MAAM;MAACW,EAAD;MAAKC;IAAL,IAAWtM,OAAO,CAACoM,UAAD,EAAaD,IAAb,CAAxB;;IACA,MAAMI,SAAS,GAAGH,UAAU,CAACC,EAAD,CAAV,IAAkBF,IAAlB,GAAyBC,UAAU,CAACC,EAAD,CAAnC,GAA0CD,UAAU,CAACE,EAAD,CAAtE;IACAJ,KAAK,CAACK,SAAD,CAAL,GAAmB,IAAnB;EACD;AACF;;AACD,MAAMC,mBAAmB,GAAG,CAC1B,sBAD0B,EAE1B,kBAF0B,EAG1B,kBAH0B,EAI1B,aAJ0B,EAK1B,eAL0B,EAM1B,YAN0B,EAO1B,gBAP0B,EAQ1B,2BAR0B,EAS1B,uBAT0B,EAU1B,uBAV0B,EAW1B,kBAX0B,EAY1B,iBAZ0B,EAa1B,aAb0B,EAc1B,eAd0B,EAe1B,aAf0B,EAgB1B,sBAhB0B,EAiB1B,kBAjB0B,EAkB1B,kBAlB0B,EAmB1B,aAnB0B,EAoB1B,WApB0B,EAqB1B,QArB0B,EAsB1B,UAtB0B,CAA5B;;AAwBA,SAASC,KAAT,CAAe9L,KAAf,EAAsB;EACpB,MAAM;IAACM,KAAD;IAAQiH,EAAR;IAAYzH;EAAZ,IAAmBE,KAAzB;EACA,MAAMwH,QAAQ,GAAGzH,aAAa,CAACC,KAAD,EAAQ,UAAR,CAA9B;EACA,MAAMyH,KAAK,GAAG1H,aAAa,CAACC,KAAD,EAAQ,OAAR,CAA3B;EACA,MAAM+L,GAAG,GAAGhM,aAAa,CAACC,KAAD,EAAQ,KAAR,CAAzB;EACA,MAAMgM,KAAK,GAAGjM,aAAa,CAACC,KAAD,EAAQ,OAAR,CAA3B;EACA,MAAMH,GAAG,GAAG8B,IAAI,CAACD,GAAL,MAAce,KAAK,CAACsJ,GAAD,CAAL,GAAavE,QAAQ,GAAGC,KAAxB,GAAgCsE,GAA9C,CAAZ;EACA,IAAIlB,CAAJ,EAAOoB,KAAP,EAAcC,KAAd,EAAqBC,YAArB;EACAtN,IAAI,CAACyB,KAAK,CAAC8L,IAAN,CAAWC,QAAZ,EAAsB,CAACC,OAAD,EAAU3F,YAAV,KAA2B;IACnD,MAAMF,IAAI,GAAGnG,KAAK,CAACoG,cAAN,CAAqBC,YAArB,CAAb;IACA,MAAMoB,IAAI,GAAGR,EAAE,KAAKd,IAAI,CAAC5F,OAAZ,IAAuB,GAAvB,IAA8B0G,EAAE,KAAKd,IAAI,CAAC3F,OAAZ,IAAuB,GAAlE;;IACA,IAAIiH,IAAJ,EAAU;MACR,MAAMwE,UAAU,GAAG9F,IAAI,CAAC8F,UAAxB;MACA,MAAMH,IAAI,GAAGE,OAAO,CAACF,IAArB;MACA,MAAMrB,MAAM,GAAGqB,IAAI,CAACrB,MAApB;;MACA,IAAIiB,KAAJ,EAAW;QACT,KAAKnB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGE,MAAhB,EAAwB,EAAEF,CAA1B,EAA6B;UAC3B,MAAM2B,KAAK,GAAGD,UAAU,CAACE,SAAX,CAAqB5B,CAArB,CAAd;;UACA,IAAI2B,KAAK,IAAI,EAAEA,KAAK,CAACzE,IAAD,CAAL,GAAcjI,GAAhB,CAAb,EAAmC;YACjC;UACD;QACF;;QACDmM,KAAK,GAAGpB,CAAC,GAAG,CAAZ;MACD,CARD,MAQO;QACLoB,KAAK,GAAG,CAAR;MACD;;MACD,KAAKpB,CAAC,GAAGoB,KAAT,EAAgBpB,CAAC,GAAGE,MAApB,EAA4B,EAAEF,CAA9B,EAAiC;QAC/B,MAAM2B,KAAK,GAAGD,UAAU,CAACE,SAAX,CAAqB5B,CAArB,CAAd;;QACA,IAAI,CAAC2B,KAAD,IAAU,EAAEA,KAAK,CAACzE,IAAD,CAAL,IAAelI,GAAjB,CAAd,EAAqC;UACnC;QACD;MACF;;MACDqM,KAAK,GAAGrB,CAAC,GAAGoB,KAAZ;;MACA,IAAIxJ,KAAK,CAACsJ,GAAD,CAAT,EAAgB;QACdG,KAAK,GAAGtM,IAAI,CAACE,GAAL,CAASoM,KAAK,GAAG,CAAjB,EAAoB,CAApB,CAAR;MACD;;MACDE,IAAI,CAACM,MAAL,CAAYT,KAAZ,EAAmBC,KAAnB;MACArN,IAAI,CAACgN,mBAAD,EAAsB5L,GAAG,IAAI;QAC/B,IAAIX,OAAO,CAACgN,OAAO,CAACrM,GAAD,CAAR,CAAX,EAA2B;UACzBqM,OAAO,CAACrM,GAAD,CAAP,CAAayM,MAAb,CAAoBT,KAApB,EAA2BC,KAA3B;QACD;MACF,CAJG,CAAJ;MAKArN,IAAI,CAACyN,OAAO,CAACK,UAAT,EAAqBlN,KAAK,IAAI;QAChC,IAAIH,OAAO,CAACG,KAAD,CAAX,EAAoB;UAClBA,KAAK,CAACiN,MAAN,CAAaT,KAAb,EAAoBC,KAApB;QACD;MACF,CAJG,CAAJ;;MAKA,IAAI,OAAOE,IAAI,CAAC,CAAD,CAAX,KAAmB,QAAvB,EAAiC;QAC/BD,YAAY,GAAG;UACbF,KAAK,EAAEA,KADM;UAEbC,KAAK,EAAEA;QAFM,CAAf;MAID;;MACDrN,IAAI,CAACyB,KAAK,CAACsM,OAAP,EAAgB,CAACC,IAAD,EAAOC,KAAP,KAAiB;QACnC,IAAID,IAAI,CAAClG,YAAL,KAAsBA,YAAtB,IAAsCkG,IAAI,CAACC,KAAL,IAAcb,KAAxD,EAA+D;UAC7D,IAAIY,IAAI,CAACC,KAAL,IAAcb,KAAK,GAAGC,KAA1B,EAAiC;YAC/BW,IAAI,CAACC,KAAL,IAAcZ,KAAd;UACD,CAFD,MAEO;YACL5L,KAAK,CAACsM,OAAN,CAAcF,MAAd,CAAqBI,KAArB,EAA4B,CAA5B;UACD;QACF;MACF,CARG,EAQD,IARC,EAQK,IARL,CAAJ;IASD;EACF,CAvDG,CAAJ;;EAwDA,IAAIX,YAAJ,EAAkB;IAChB7L,KAAK,CAAC8L,IAAN,CAAWW,MAAX,CAAkBL,MAAlB,CAAyBP,YAAY,CAACF,KAAtC,EAA6CE,YAAY,CAACD,KAA1D;EACD;AACF;;AACD,SAAS9C,UAAT,CAAoB1I,OAApB,EAA6B6G,EAA7B,EAAiCyF,SAAjC,EAA4C;EAC1C,MAAMC,UAAU,GAAGvM,OAAO,CAACwM,WAAR,IAAuB,EAA1C;EACArO,IAAI,CAAC6B,OAAO,CAACoD,UAAT,EAAqB,CAAC+I,IAAD,EAAO5M,GAAP,KAAe;IACtC,IAAI4M,IAAI,CAAC7L,MAAL,KAAgBuG,EAApB,EAAwB;MACtB,MAAMkB,KAAK,GAAGoE,IAAI,CAAC9I,OAAL,GAAe,CAACiJ,SAAhB,GAA4BA,SAA1C;MACA,MAAMjH,SAAS,GAAGkH,UAAU,CAAChN,GAAD,CAA5B;;MACA,IAAIhB,QAAQ,CAACyB,OAAO,CAACT,GAAD,CAAR,CAAZ,EAA4B;QAC1BS,OAAO,CAACT,GAAD,CAAP,IAAgBwI,KAAhB;MACD;;MACD,IAAI1C,SAAJ,EAAe;QACbA,SAAS,CAACoH,KAAV,IAAmB1E,KAAnB;QACA1C,SAAS,CAACqH,GAAV,IAAiB3E,KAAjB;MACD;IACF;EACF,CAZG,CAAJ;AAaD;;AACD,SAAS4E,MAAT,CAAgBrN,KAAhB,EAAuB;EACrB,MAAM;IAACM,KAAD;IAAQiH,EAAR;IAAY+F,SAAS,EAAElN;EAAvB,IAAmCJ,KAAzC;EACA,MAAMwH,QAAQ,GAAGzH,aAAa,CAACC,KAAD,EAAQ,UAAR,CAA9B;EACA,MAAMyH,KAAK,GAAG1H,aAAa,CAACC,KAAD,EAAQ,OAAR,CAA3B;EACA,MAAMoE,YAAY,GAAGpE,KAAK,CAACoE,YAAN,EAArB;EACA,MAAM2G,MAAM,GAAG3G,YAAY,GAAGpE,KAAK,CAACgE,KAAT,GAAiBhE,KAAK,CAACiE,MAAlD;EACA,MAAMvC,GAAG,GAAGC,IAAI,CAACD,GAAL,EAAZ;EACA,MAAM6L,OAAO,GAAGjN,KAAK,CAACiN,OAAtB;EACA,MAAMC,WAAW,GAAGxH,WAAW,CAAC1F,KAAD,CAA/B;EACA,IAAImN,MAAM,GAAG1C,MAAM,IAAIrJ,GAAG,GAAGtB,QAAQ,CAACsN,IAAnB,CAAN,GAAiClG,QAA9C;;EACA,IAAIpD,YAAY,KAAK,CAAC,CAACpE,KAAK,CAACG,OAAN,CAAc4D,OAArC,EAA8C;IAC5C0J,MAAM,GAAG,CAACA,MAAV;EACD;;EACD5O,IAAI,CAACyB,KAAK,CAAC8L,IAAN,CAAWC,QAAZ,EAAsB,CAACC,OAAD,EAAU3F,YAAV,KAA2B;IACnD,MAAMF,IAAI,GAAGnG,KAAK,CAACoG,cAAN,CAAqBC,YAArB,CAAb;IACA,MAAM;MAACyF,IAAI,EAAEjG,QAAQ,GAAG,EAAlB;MAAsBmG,OAAO,EAAE5L;IAA/B,IAA0C+F,IAAhD;;IACA,KAAK,IAAIoE,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG3E,QAAQ,CAAC4E,MAAhC,EAAwCF,CAAC,GAAGC,IAA5C,EAAkD,EAAED,CAApD,EAAuD;MACrDzB,UAAU,CAACjD,QAAQ,CAAC0E,CAAD,CAAT,EAActD,EAAd,EAAkBkG,MAAlB,CAAV;IACD;;IACD,IAAI/M,OAAJ,EAAa;MACX0I,UAAU,CAAC1I,OAAD,EAAU6G,EAAV,EAAckG,MAAd,CAAV;MACA,OAAO/M,OAAO,CAACiN,KAAf;IACD;EACF,CAVG,CAAJ;;EAWA,KAAK,IAAI9C,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG0C,WAAW,CAACzC,MAAnC,EAA2CF,CAAC,GAAGC,IAA/C,EAAqD,EAAED,CAAvD,EAA0D;IACxDzB,UAAU,CAACoE,WAAW,CAAC3C,CAAD,CAAZ,EAAiBtD,EAAjB,EAAqBkG,MAArB,CAAV;EACD;;EACD,IAAIF,OAAJ,EAAa;IACXnE,UAAU,CAACmE,OAAD,EAAUhG,EAAV,EAAckG,MAAd,CAAV;EACD;;EACDzN,KAAK,CAACF,GAAN,GAAY4B,GAAG,GAAG+F,KAAlB;EACAzH,KAAK,CAACH,GAAN,GAAYG,KAAK,CAACF,GAAN,GAAY0H,QAAxB;EACApH,QAAQ,CAACsN,IAAT,GAAgBhM,GAAhB;AACD;;AACD,MAAMkM,aAAN,SAA4BpP,SAA5B,CAAsC;EACpCoI,WAAW,CAACiH,KAAD,EAAQ;IACjB,MAAMA,KAAN;IACA,KAAKP,SAAL,GAAiB,KAAKA,SAAL,IAAkB,EAAnC;EACD;;EACDQ,IAAI,CAACC,SAAD,EAAYC,IAAZ,EAAkB;IACpB,MAAMzH,EAAE,GAAG,IAAX;IACA,MAAMuH,IAAN,CAAWC,SAAX,EAAsBC,IAAtB;IACA3L,qBAAqB,CAACkE,EAAE,CAAC+G,SAAJ,EAAe,MAAM;MACxC,MAAMhN,KAAK,GAAGiG,EAAE,CAACjG,KAAjB;MACA,MAAM2N,SAAS,GAAGlO,aAAa,CAACwG,EAAD,EAAK,WAAL,CAA/B;MACAxH,QAAQ,CAACkP,SAAD,EAAY,CAAC3N,KAAD,CAAZ,EAAqBiG,EAArB,CAAR;MACAuF,KAAK,CAACvF,EAAD,CAAL;MACAjG,KAAK,CAACuG,MAAN,CAAa,OAAb;MACA,OAAO9G,aAAa,CAACwG,EAAD,EAAK,SAAL,CAApB;IACD,CAPoB,CAArB;EAQD;;EACDM,MAAM,CAACqH,QAAD,EAAWC,SAAX,EAAsBC,OAAtB,EAA+B;IACnC,MAAM7H,EAAE,GAAG,IAAX;IACA,MAAM;MAAC+G,SAAS,EAAElN,QAAZ;MAAsBD;IAAtB,IAAiCoG,EAAvC;IACA,MAAM;MAAC8H,MAAD;MAASZ,MAAT;MAAiBlC,KAAK,EAAE+C;IAAxB,IAAqCnO,OAA3C;IACA,MAAM;MAACoO,QAAD;MAAWC,MAAX;MAAmBC,KAAK,EAAEC;IAA1B,IAA4CJ,SAAlD;IACA,MAAMK,YAAY,GAAGD,cAAc,CAACE,OAApC;;IACA,IAAI7O,aAAa,CAACwG,EAAD,EAAK,OAAL,CAAjB,EAAgC;MAC9BvE,qBAAqB,CAAC5B,QAAD,CAArB;IACD,CAFD,MAEO;MACL,IAAI,CAACA,QAAQ,CAACmB,cAAd,EAA8B;QAC5BnB,QAAQ,CAACsN,IAAT,GAAgB/L,IAAI,CAACD,GAAL,EAAhB;MACD;;MACDN,sBAAsB,CAAChB,QAAD,EAAW,MAAM;QACrC,MAAME,KAAK,GAAGiG,EAAE,CAACjG,KAAjB;QACA,MAAME,SAAS,GAAGF,KAAK,CAACwD,UAAxB;QACAuJ,MAAM,CAAC9G,EAAD,CAAN;;QACA,IAAI/F,SAAJ,EAAe;UACbzB,QAAQ,CAACyB,SAAS,CAACqO,MAAX,EAAmB,CAACvO,KAAD,CAAnB,CAAR;QACD;;QACD,OAAOP,aAAa,CAACwG,EAAD,EAAK,WAAL,CAApB;MACD,CARqB,CAAtB;IASD;;IACDpG,OAAO,CAACkO,MAAR,GAAiBS,SAAjB;IACA3O,OAAO,CAACsN,MAAR,GAAiB,KAAjB;IACAa,SAAS,CAACC,QAAV,GAAqB,KAArB;IACAD,SAAS,CAACE,MAAV,GAAmBA,MAAM,KAAK,MAAX,GAAoB,EAApB,GAAyBA,MAA5C;IACAE,cAAc,CAACE,OAAf,GAAyB,IAAzB;IACA,MAAM/H,MAAN,CAAaqH,QAAb,EAAuBC,SAAvB,EAAkCC,OAAlC;IACAjO,OAAO,CAACkO,MAAR,GAAiBA,MAAjB;IACAlO,OAAO,CAACsN,MAAR,GAAiBA,MAAjB;IACAa,SAAS,CAACC,QAAV,GAAqBA,QAArB;IACAD,SAAS,CAACE,MAAV,GAAmBA,MAAnB;IACAE,cAAc,CAACE,OAAf,GAAyBD,YAAzB;EACD;;EACDI,UAAU,GAAG;IACX,MAAMxI,EAAE,GAAG,IAAX;IACA,MAAMiB,QAAQ,GAAGzH,aAAa,CAACwG,EAAD,EAAK,UAAL,CAA9B;IACA,MAAMkB,KAAK,GAAG1H,aAAa,CAACwG,EAAD,EAAK,OAAL,CAA3B;IACA,MAAMzG,GAAG,GAAGyG,EAAE,CAAC+G,SAAH,CAAaI,IAAb,GAAoBjG,KAAhC;IACA,MAAM5H,GAAG,GAAGC,GAAG,GAAG0H,QAAlB;IACA,MAAMwH,QAAQ,GAAG,CAAC,IAAD,EAAOlP,GAAP,CAAjB;IACA,MAAMmP,QAAQ,GAAG,CAAC,CAAC,IAAF,EAAQpP,GAAR,CAAjB;IACAuK,MAAM,CAAC8E,cAAP,CAAsB3I,EAAtB,EAA0B,KAA1B,EAAiC;MAC/BU,GAAG,EAAE,MAAMgI,QAAQ,CAACE,KAAT,EADoB;MAE/BhI,GAAG,EAAEnI;IAF0B,CAAjC;IAIAoL,MAAM,CAAC8E,cAAP,CAAsB3I,EAAtB,EAA0B,KAA1B,EAAiC;MAC/BU,GAAG,EAAE,MAAM+H,QAAQ,CAACG,KAAT,EADoB;MAE/BhI,GAAG,EAAEnI;IAF0B,CAAjC;IAIA,MAAMuM,KAAK,GAAG,MAAMwD,UAAN,EAAd;IACA,OAAOxI,EAAE,CAAC1G,GAAV;IACA,OAAO0G,EAAE,CAACzG,GAAV;IACAyG,EAAE,CAAC1G,GAAH,GAASA,GAAT;IACA0G,EAAE,CAACzG,GAAH,GAASA,GAAT;IACA,OAAOyL,KAAP;EACD;;EACD6D,sBAAsB,GAAG;IACvB,MAAMd,SAAS,GAAG,KAAKnO,OAAL,CAAaoL,KAA/B;IACA,MAAM8D,WAAW,GAAGf,SAAS,CAACe,WAA9B;IACAf,SAAS,CAACe,WAAV,GAAwBf,SAAS,CAACgB,WAAV,IAAyB,CAAjD;IACA,MAAMF,sBAAN;IACAd,SAAS,CAACe,WAAV,GAAwBA,WAAxB;EACD;;EACDE,GAAG,GAAG;IACJ,MAAMhJ,EAAE,GAAG,IAAX;IACA,MAAMpG,OAAO,GAAGoG,EAAE,CAACpG,OAAnB;IACA,MAAMoP,GAAN;;IACA,IAAIpP,OAAO,CAACoL,KAAR,CAAciE,OAAd,IAAyBrP,OAAO,CAACqP,OAAjC,IAA4CjJ,EAAE,CAACnC,YAAH,EAAhD,EAAmE;MACjEmC,EAAE,CAACkJ,WAAH,GAAiB,CAAjB;MACAlJ,EAAE,CAACmJ,YAAH,GAAkB,CAAlB;;MACAnJ,EAAE,CAACoJ,cAAH;IACD;EACF;;EACDC,IAAI,CAAC3M,SAAD,EAAY;IACd,MAAMsD,EAAE,GAAG,IAAX;IACA,MAAM;MAACjG,KAAD;MAAQuP;IAAR,IAAetJ,EAArB;IACA,MAAMuJ,IAAI,GAAGvJ,EAAE,CAACnC,YAAH,KACX;MACET,IAAI,EAAEV,SAAS,CAACU,IADlB;MAEED,GAAG,EAAE,CAFP;MAGEG,KAAK,EAAEZ,SAAS,CAACY,KAHnB;MAIED,MAAM,EAAEtD,KAAK,CAAC2D;IAJhB,CADW,GAMP;MACFN,IAAI,EAAE,CADJ;MAEFD,GAAG,EAAET,SAAS,CAACS,GAFb;MAGFG,KAAK,EAAEvD,KAAK,CAAC0D,KAHX;MAIFJ,MAAM,EAAEX,SAAS,CAACW;IAJhB,CANN;IAYA2C,EAAE,CAACwJ,cAAH,GAAoB,IAApB;IACAxJ,EAAE,CAACyJ,WAAH,GAAiB,IAAjB;IACA9Q,QAAQ,CAAC2Q,GAAD,EAAMC,IAAN,CAAR;IACA,MAAMF,IAAN,CAAW3M,SAAX;IACA9D,UAAU,CAAC0Q,GAAD,CAAV;EACD;;EACDI,OAAO,GAAG;IACR,MAAM7P,QAAQ,GAAG,KAAKkN,SAAtB;IACAtL,qBAAqB,CAAC5B,QAAD,CAArB;IACA6B,oBAAoB,CAAC7B,QAAD,CAApB;EACD;;EACD8P,SAAS,GAAG;IACV,MAAM3J,EAAE,GAAG,IAAX;IACA,MAAM4J,OAAO,GAAG5J,EAAE,CAAC6J,QAAnB;IACA,MAAM5I,QAAQ,GAAGzH,aAAa,CAACwG,EAAD,EAAK,UAAL,CAA9B;IACA,MAAMkB,KAAK,GAAG1H,aAAa,CAACwG,EAAD,EAAK,OAAL,CAA3B;IACA,MAAM/E,OAAO,GAAGzB,aAAa,CAACwG,EAAD,EAAK,SAAL,CAA7B;IACA,MAAMzG,GAAG,GAAGyG,EAAE,CAAC+G,SAAH,CAAaI,IAAb,GAAoBjG,KAAhC;IACA,MAAM5H,GAAG,GAAGC,GAAG,GAAG0H,QAAlB;;IACA,MAAMgD,QAAQ,GAAGjE,EAAE,CAAC8J,iBAAH,CAAqBxQ,GAArB,CAAjB;;IACA,MAAM;MAAC2L,IAAI,EAAE8E,QAAP;MAAiB/E,KAAK,EAAE+C;IAAxB,IAAqC/H,EAAE,CAACpG,OAA9C;IACA,MAAMoQ,KAAK,GAAGD,QAAQ,CAAC/F,IAAT,IAAiBS,yBAAyB,CAACsF,QAAQ,CAACrF,OAAV,EAAmBpL,GAAnB,EAAwBC,GAAxB,EAA6B0K,QAA7B,CAAxD;IACA,MAAMiE,KAAK,GAAGpD,kBAAkB,CAACkF,KAAD,CAAhC;IACA,MAAMC,QAAQ,GAAGF,QAAQ,CAACE,QAAT,IAAqBlG,iBAAiB,CAACzK,GAAD,EAAMC,GAAN,EAAWyQ,KAAX,EAAkB/F,QAAlB,CAAvD;IACA,MAAMiG,OAAO,GAAGF,KAAK,KAAK,MAAV,GAAmBD,QAAQ,CAACI,UAA5B,GAAyC,KAAzD;IACA,MAAMC,iBAAiB,GAAGrC,SAAS,CAACG,KAAV,CAAgBG,OAA1C;IACA,MAAMgC,UAAU,GAAGxR,QAAQ,CAACqR,OAAD,CAAR,IAAqBA,OAAO,KAAK,IAApD;IACA,MAAMnO,QAAQ,GAAGgH,SAAS,CAACiH,KAAD,CAA1B;IACA,MAAMhF,KAAK,GAAG,EAAd;IACA,IAAIsF,KAAK,GAAGhR,GAAZ;IACA,IAAI2L,IAAJ,EAAUU,KAAV;;IACA,IAAI0E,UAAJ,EAAgB;MACdC,KAAK,GAAG,CAACV,OAAO,CAACW,OAAR,CAAgBD,KAAhB,EAAuB,SAAvB,EAAkCJ,OAAlC,CAAT;IACD;;IACDI,KAAK,GAAG,CAACV,OAAO,CAACW,OAAR,CAAgBD,KAAhB,EAAuBD,UAAU,GAAG,KAAH,GAAWL,KAA5C,CAAT;;IACA,IAAIJ,OAAO,CAACY,IAAR,CAAajR,GAAb,EAAkBD,GAAlB,EAAuB0Q,KAAvB,IAAgC,SAASC,QAA7C,EAAuD;MACrD,MAAM,IAAIQ,KAAJ,CAAUnR,GAAG,GAAG,OAAN,GAAgBC,GAAhB,GAAsB,sCAAtB,GAA+D0Q,QAA/D,GAA0E,GAA1E,GAAgFD,KAA1F,CAAN;IACD;;IACD/E,IAAI,GAAGqF,KAAP;;IACA,IAAIF,iBAAiB,IAAIlC,KAArB,IAA8B,CAACmC,UAA/B,IAA6C,CAACN,QAAQ,CAACW,KAA3D,EAAkE;MAChEzF,IAAI,GAAG,CAAC2E,OAAO,CAACW,OAAR,CAAgBtF,IAAhB,EAAsBiD,KAAtB,CAAR;MACAjD,IAAI,GAAG,CAAC2E,OAAO,CAACe,GAAR,CAAY1F,IAAZ,EAAkB,CAAC,EAAE,CAACqF,KAAK,GAAGrF,IAAT,KAAkBlJ,QAAQ,CAACmH,IAAT,GAAgB+G,QAAlC,CAAF,CAAD,GAAkDA,QAApE,EAA8ED,KAA9E,CAAR;IACD;;IACD,MAAM9E,UAAU,GAAG6C,SAAS,CAACE,MAAV,KAAqB,MAArB,IAA+BjI,EAAE,CAAC4K,iBAAH,EAAlD;;IACA,KAAKjF,KAAK,GAAG,CAAb,EAAgBV,IAAI,GAAG1L,GAAG,GAAG0B,OAA7B,EAAsCgK,IAAI,GAAG,CAAC2E,OAAO,CAACe,GAAR,CAAY1F,IAAZ,EAAkBgF,QAAlB,EAA4BD,KAA5B,CAAR,EAA4CrE,KAAK,EAAvF,EAA2F;MACzFZ,OAAO,CAACC,KAAD,EAAQC,IAAR,EAAcC,UAAd,CAAP;IACD;;IACD,IAAID,IAAI,KAAK1L,GAAG,GAAG0B,OAAf,IAA0B0K,KAAK,KAAK,CAAxC,EAA2C;MACzCZ,OAAO,CAACC,KAAD,EAAQC,IAAR,EAAcC,UAAd,CAAP;IACD;;IACD,OAAOrB,MAAM,CAACC,IAAP,CAAYkB,KAAZ,EAAmB6F,IAAnB,CAAwB,CAACC,CAAD,EAAIC,CAAJ,KAAUD,CAAC,GAAGC,CAAtC,EAAyCC,GAAzC,CAA6C5Q,CAAC,IAAI,CAACA,CAAnD,CAAP;EACD;;AA7JmC;;AA+JtCiN,aAAa,CAACrG,EAAd,GAAmB,UAAnB;AACAqG,aAAa,CAACnP,QAAd,GAAyB;EACvB4P,MAAM,EAAE,MADe;EAEvBmD,QAAQ,EAAE,EAFa;EAGvBhG,IAAI,EAAE;IACJiG,MAAM,EAAE,KADJ;IAEJlH,IAAI,EAAE,KAFF;IAGJ0G,KAAK,EAAE,KAHH;IAIJP,UAAU,EAAE,KAJR;IAKJzF,OAAO,EAAE,aALL;IAMJyG,cAAc,EAAE;EANZ,CAHiB;EAWvBtR,QAAQ,EAAE,EAXa;EAYvBmL,KAAK,EAAE;IACLgD,QAAQ,EAAE,KADL;IAELC,MAAM,EAAE,MAFH;IAGLC,KAAK,EAAE;MACLG,OAAO,EAAE;IADJ;EAHF;AAZgB,CAAzB;AAoBAnQ,QAAQ,CAACkT,QAAT,CAAkB,gBAAlB,EAAoC;EAClCC,WAAW,EAAEC,IAAI,IAAIA,IAAI,KAAK;AADI,CAApC;AAIA,IAAIC,OAAO,GAAG,OAAd;AAEArT,QAAQ,CAAC0I,GAAT,CAAa,aAAb,EAA4B;EAC1B4K,KAAK,EAAE;IACLhM,SAAS,EAAE;MACTyB,QAAQ,EAAE;IADD;EADN;AADmB,CAA5B;AAOA,MAAMwK,cAAc,GAAG;EAACrR,CAAC,EAAE,CAAC,GAAD,EAAM,MAAN,EAAc,MAAd,CAAJ;EAA2BC,CAAC,EAAE,CAAC,GAAD,EAAM,MAAN,EAAc,MAAd;AAA9B,CAAvB;;AACA,SAASiG,MAAT,CAAgBhB,IAAhB,EAAsB;EACpB,MAAMU,EAAE,GAAG,IAAX;;EACA,IAAIV,IAAI,KAAK,OAAb,EAAsB;IACpBhH,IAAI,CAAC0H,EAAE,CAAC6F,IAAH,CAAQC,QAAT,EAAmB,CAACC,OAAD,EAAU3F,YAAV,KAA2B;MAChD,MAAM4F,UAAU,GAAGhG,EAAE,CAACG,cAAH,CAAkBC,YAAlB,EAAgC4F,UAAnD;;MACAA,UAAU,CAAC0F,SAAX,GAAuB,UAASvR,OAAT,EAAkBoM,KAAlB,EAAyBoF,KAAzB,EAAgCC,MAAhC,EAAwC;QAC7DzT,iBAAiB,CAACwG,SAAlB,CAA4B+M,SAA5B,CAAsClQ,IAAtC,CAA2C,IAA3C,EAAiDrB,OAAjD,EAA0DoM,KAA1D,EAAiE,OAAjE,EAA0EqF,MAA1E;MACD,CAFD;IAGD,CALG,CAAJ;EAMD;;EACDxT,KAAK,CAACuG,SAAN,CAAgB2B,MAAhB,CAAuB9E,IAAvB,CAA4BwE,EAA5B,EAAgCV,IAAhC;;EACA,IAAIA,IAAI,KAAK,OAAb,EAAsB;IACpBhH,IAAI,CAAC0H,EAAE,CAAC6F,IAAH,CAAQC,QAAT,EAAmB,CAACC,OAAD,EAAU3F,YAAV,KAA2B;MAChD,OAAOJ,EAAE,CAACG,cAAH,CAAkBC,YAAlB,EAAgC4F,UAAhC,CAA2C0F,SAAlD;IACD,CAFG,CAAJ;EAGD;AACF;;AACD,SAASpD,MAAT,CAAgBvO,KAAhB,EAAuB;EACrB,MAAME,SAAS,GAAGF,KAAK,CAACwD,UAAxB;EACAxD,KAAK,CAACuO,MAAN;;EACA,IAAIrO,SAAS,CAAC4R,cAAd,EAA8B;IAC5BC,UAAU,CAAC,MAAM;MACf,MAAMD,cAAc,GAAG5R,SAAS,CAAC4R,cAAjC;;MACA,IAAIA,cAAJ,EAAoB;QAClB9R,KAAK,CAACgS,aAAN,CAAoBF,cAApB;MACD;IACF,CALS,EAKP,CALO,CAAV;EAMD;AACF;;AACD,IAAIG,eAAe,GAAG;EACpBhL,EAAE,EAAE,WADgB;EAEpBuK,OAFoB;;EAGpBU,UAAU,CAAClS,KAAD,EAAQ;IAChB,MAAME,SAAS,GAAGF,KAAK,CAACwD,UAAN,GAAmBxD,KAAK,CAACwD,UAAN,IAAoB;MAAC+K;IAAD,CAAzD;IACA,MAAM4D,MAAM,GAAGjS,SAAS,CAACiS,MAAV,GAAmBnS,KAAK,CAACmS,MAAxC;;IACA,MAAMC,kBAAkB,GAAGlS,SAAS,CAACkS,kBAAV,GAA+BC,KAAK,IAAI;MACjE,MAAMC,GAAG,GAAGrT,mBAAmB,CAACoT,KAAD,EAAQrS,KAAR,CAA/B;MACAE,SAAS,CAAC4R,cAAV,GAA2B;QACzBS,IAAI,EAAE,WADmB;QAEzBvS,KAAK,EAAEA,KAFkB;QAGzBwS,MAAM,EAAEH,KAHiB;QAIzBhS,CAAC,EAAEiS,GAAG,CAACjS,CAJkB;QAKzBC,CAAC,EAAEgS,GAAG,CAAChS;MALkB,CAA3B;IAOD,CATD;;IAUA6R,MAAM,CAACM,gBAAP,CAAwB,WAAxB,EAAqCL,kBAArC;IACAD,MAAM,CAACM,gBAAP,CAAwB,SAAxB,EAAmCL,kBAAnC;EACD,CAlBmB;;EAmBpBM,SAAS,CAAC1S,KAAD,EAAQ;IACfA,KAAK,CAACuG,MAAN,GAAeA,MAAf;EACD,CArBmB;;EAsBpBoM,YAAY,CAAC3S,KAAD,EAAQ;IAClB,MAAM;MAAC0C,MAAD;MAASmD;IAAT,IAAqB7F,KAAK,CAACH,OAAjC;IACA,MAAMoN,OAAO,GAAGjN,KAAK,CAACiN,OAAtB;IACA1O,IAAI,CAACmE,MAAD,EAAS,SAAY;MAAA,IAAX;QAAC6P;MAAD,CAAW;;MACvB,IAAIA,IAAI,KAAK,UAAb,EAAyB;QACvB1M,QAAQ,CAAC+M,IAAT,CAAcC,eAAd,GAAgC,KAAhC;MACD;IACF,CAJG,CAAJ;;IAKA,IAAI5F,OAAJ,EAAa;MACXA,OAAO,CAAC1G,MAAR,GAAiBP,QAAjB;IACD;;IACD,IAAI;MACF,MAAMd,MAAM,GAAGjH,QAAQ,CAAC6U,SAAT,CAAmB,YAAnB,CAAf;MACA7N,aAAa,CAACC,MAAD,EAASlF,KAAT,CAAb;IACD,CAHD,CAGE,OAAO+S,CAAP,EAAU;MACVjN,aAAa,CAAC9F,KAAD,CAAb;IACD;;IACD,IAAI;MACF,MAAMkF,MAAM,GAAGjH,QAAQ,CAAC6U,SAAT,CAAmB,MAAnB,CAAf;MACAnK,WAAW,CAACzD,MAAD,EAASlF,KAAT,CAAX;IACD,CAHD,CAGE,OAAO+S,CAAP,EAAU;MACVhK,WAAW,CAAC/I,KAAD,CAAX;IACD;EACF,CA7CmB;;EA8CpBgT,mBAAmB,CAAChT,KAAD,EAAQsF,IAAR,EAAc;IAC/B,MAAM;MAACa,IAAD;MAAOZ;IAAP,IAAeD,IAArB;;IACA,IAAIC,IAAI,KAAK,OAAb,EAAsB;MACpB,MAAM;QAAC0G,UAAD;QAAaW;MAAb,IAA4BzG,IAAlC;;MACA,IAAIyG,WAAW,IAAIA,WAAW,CAACqG,OAA3B,IAAsCrG,WAAW,CAACqG,OAAZ,CAAoB3G,OAA9D,EAAuE;QACrEL,UAAU,CAACiH,aAAX,GAA2BxU,IAA3B;QACAuN,UAAU,CAACkH,mBAAX,GAAiCzU,IAAjC;MACD;IACF;EACF,CAvDmB;;EAwDpB0U,kBAAkB,CAACpT,KAAD,EAAQsF,IAAR,EAAc;IAC9B,MAAM;MAACa,IAAD;MAAOZ;IAAP,IAAeD,IAArB;IACA,MAAM;MAACwG,IAAI,EAAEjG,QAAQ,GAAG,EAAlB;MAAsBmG,OAAO,EAAE5L,OAA/B;MAAwC6L;IAAxC,IAAsD9F,IAA5D;;IACA,KAAK,IAAIoE,CAAC,GAAG,CAAR,EAAWC,IAAI,GAAG3E,QAAQ,CAAC4E,MAAhC,EAAwCF,CAAC,GAAGC,IAA5C,EAAkD,EAAED,CAApD,EAAuD;MACrD1E,QAAQ,CAAC0E,CAAD,CAAR,CAAY/G,UAAZ,GAAyBrD,UAAU,CAAC0F,QAAQ,CAAC0E,CAAD,CAAT,EAAcmH,cAAd,EAA8BvL,IAA9B,CAAnC;IACD;;IACD,IAAI/F,OAAJ,EAAa;MACXA,OAAO,CAACoD,UAAR,GAAqBrD,UAAU,CAACC,OAAD,EAAUsR,cAAV,EAA0BvL,IAA1B,CAA/B;IACD;;IACD,IAAIZ,IAAI,KAAK,OAAb,EAAsB;MACpB,OAAO0G,UAAU,CAACiH,aAAlB;MACA,OAAOjH,UAAU,CAACkH,mBAAlB;IACD;EACF,CArEmB;;EAsEpBE,iBAAiB,CAACrT,KAAD,EAAQsF,IAAR,EAAc;IAC7B,MAAM;MAACiK,GAAD;MAAM5M,SAAN;MAAiBe,KAAjB;MAAwBC;IAAxB,IAAkC3D,KAAxC;IACA,MAAM;MAACO,OAAD;MAAUC,OAAV;MAAmByL;IAAnB,IAAiC3G,IAAI,CAACa,IAA5C;IACA,MAAMqJ,IAAI,GAAG;MACXnM,IAAI,EAAE,CADK;MAEXD,GAAG,EAAE,CAFM;MAGXG,KAAK,EAAEG,KAHI;MAIXJ,MAAM,EAAEK;IAJG,CAAb;;IAMA,IAAIpD,OAAO,IAAI0L,UAAU,CAACqH,aAAX,CAAyB/S,OAAzB,aAA6C+M,aAA5D,EAA2E;MACzEkC,IAAI,CAACnM,IAAL,GAAYV,SAAS,CAACU,IAAtB;MACAmM,IAAI,CAACjM,KAAL,GAAaZ,SAAS,CAACY,KAAvB;IACD;;IACD,IAAI/C,OAAO,IAAIyL,UAAU,CAACqH,aAAX,CAAyB9S,OAAzB,aAA6C8M,aAA5D,EAA2E;MACzEkC,IAAI,CAACpM,GAAL,GAAWT,SAAS,CAACS,GAArB;MACAoM,IAAI,CAAClM,MAAL,GAAcX,SAAS,CAACW,MAAxB;IACD;;IACD1E,QAAQ,CAAC2Q,GAAD,EAAMC,IAAN,CAAR;EACD,CAxFmB;;EAyFpB+D,gBAAgB,CAACvT,KAAD,EAAQ;IACtBnB,UAAU,CAACmB,KAAK,CAACuP,GAAP,CAAV;EACD,CA3FmB;;EA4FpBiE,WAAW,CAACxT,KAAD,EAAQsF,IAAR,EAAc;IACvB,MAAMpF,SAAS,GAAGF,KAAK,CAACwD,UAAxB;IACA,MAAM6O,KAAK,GAAG/M,IAAI,CAAC+M,KAAnB;;IACA,IAAIA,KAAK,CAACE,IAAN,KAAe,WAAnB,EAAgC;MAC9BrS,SAAS,CAAC4R,cAAV,GAA2BO,KAA3B;IACD,CAFD,MAEO,IAAIA,KAAK,CAACE,IAAN,KAAe,UAAnB,EAA+B;MACpC,OAAOrS,SAAS,CAAC4R,cAAjB;IACD;EACF,CApGmB;;EAqGpBnC,OAAO,CAAC3P,KAAD,EAAQ;IACb,MAAM;MAAC0C,MAAD;MAASc,UAAU,EAAEtD,SAArB;MAAgC+M;IAAhC,IAA2CjN,KAAjD;IACA,MAAM;MAACmS,MAAD;MAASC;IAAT,IAA+BlS,SAArC;IACA,OAAOF,KAAK,CAACuG,MAAb;;IACA,IAAI0G,OAAJ,EAAa;MACX,OAAOA,OAAO,CAAC1G,MAAf;IACD;;IACD4L,MAAM,CAACsB,mBAAP,CAA2B,WAA3B,EAAwCrB,kBAAxC;IACAD,MAAM,CAACsB,mBAAP,CAA2B,SAA3B,EAAsCrB,kBAAtC;IACA7T,IAAI,CAACmE,MAAD,EAAShD,KAAK,IAAI;MACpB,IAAIA,KAAK,YAAY4N,aAArB,EAAoC;QAClC5N,KAAK,CAACiQ,OAAN;MACD;IACF,CAJG,CAAJ;EAKD,CAnHmB;;EAoHpBxR,QAAQ,EAAE;IACR+I,QAAQ,EAAE,KADF;IAERC,KAAK,EAAE,CAFC;IAGRuM,SAAS,EAAE,EAHH;IAIRxS,OAAO,EAAE,IAJD;IAKRyM,SAAS,EAAE,IALH;IAMRjC,KAAK,EAAE,KANC;IAORD,GAAG,EAAE+C;EAPG,CApHU;EA6HpBmF,WAAW,EAAE;IACXrC,WAAW,EAAEC,IAAI,IAAIA,IAAI,KAAK;EADnB;AA7HO,CAAtB;AAkIA,MAAMqC,aAAa,GAAG,CAAC3B,eAAD,EAAkB3E,aAAlB,CAAtB;AAEA,eAAesG,aAAf;AACA,SAAStG,aAAT,EAAwB2E,eAAxB"},"metadata":{},"sourceType":"module"}